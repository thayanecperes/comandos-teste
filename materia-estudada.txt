# GITHUB - Comandos

[GitHub - thayanecperes/comandos-teste: Testando comandos GIT](https://github.com/thayanecperes/comandos-teste/tree/main)

[Git e Github para SobrevivÃªncia | Alura Cursos Online](https://www.alura.com.br/webseries/git-e-github-para-sobrevivencia/)

Para que possamos realizar o controle de versÃ£o de um projeto, registrando as mudanÃ§as realizadas nele ao longo do tempo, devemos, primeiramente, transformar o diretÃ³rio do projeto em um repositÃ³rio Git. 

## Git init:

O comandoÂ `git init`Â Ã© utilizado para esse objetivo, devendo ser executado apenasÂ **uma vez**. Quando executado, ele configura o diretÃ³rio atual para ser rastreado pelo Git, inicializando um repositÃ³rio vazio.

### **Cuidados com o comando git init**

Aprendemos que o comandoÂ `git init`Â serve para criar um novo repositÃ³rio Git e por isso deve ser executado apenas uma Ãºnica vez. Ou seja, se um diretÃ³rio jÃ¡ for um repositÃ³rio Git, nÃ£o faz sentido rodar novamente o comandoÂ `git init`. Esse Ã© um erro bastante comum de ser cometido.

---

## Git add:

Git add Ã© usado para adicionar as alteraÃ§Ãµes dos arquivos do repositÃ³rio no Git para em seguida ser realizado o commit. 

```sql
git add nome-do-arquivo.txt
```

Para facilitar esse processo, temos um atalho no comando do Git, onde podemosÂ **adicionar todos os arquivos de uma sÃ³ vez**. Ã‰ o comandoÂ `git add .`. Esse ponto vai adicionar todos os arquivos do repositÃ³rio. 

---

## Git commit:

O prÃ³ximo comando que encontramos Ã© oÂ `git commit -m`Â e temos que inserir uma mensagem entre aspas. Copiamos atÃ© oÂ `-m`, porque vamos alterar a mensagem. Colocaremos a mensagemÂ `projeto inicial`Â entre aspas duplas.

```sql
gitcommit -m "projeto inicial"
```

Apesar de nÃ£o existir uma regra universal para a escrita das mensagens de commit, algumas boas prÃ¡ticas podem ser seguidas para garantir que outras pessoas, e atÃ© mesmo vocÃª no futuro, entendam que alteraÃ§Ãµes foram feitas e por quÃª.

As mensagens dos commits devem serÂ **simples e objetivas**. A seguir, listamos algumas orientaÃ§Ãµes para isso:

- **Mantenha a mensagem curta e concisa:**Â A primeira linha da mensagem deve conter, no mÃ¡ximo, 72 caracteres. Caso seja necessÃ¡rio uma descriÃ§Ã£o adicional, vocÃª deve pular uma linha e adicionar os detalhes, como o contexto, da mudanÃ§a realizada.
- **Uso de verbo no infinitivo:**Â Ã‰ comum que a mensagem do commit inicie com um verbo no infinitivo que descreva a alteraÃ§Ã£o feita, como â€œadicionarâ€, â€œcorrigirâ€ ou â€œatualizarâ€. Em sequÃªncia, sÃ£o adicionados detalhes concisos da mudanÃ§a. Por exemplo: â€œAtualizar texto do tÃ­tulo da pÃ¡ginaâ€.
- **Evite detalhes tÃ©cnicos**: NÃ£o inclua detalhes tÃ©cnicos complexos na mensagem de commit. Esses detalhes podem ser adicionados nos comentÃ¡rios de cÃ³digo ou na documentaÃ§Ã£o.

Ã‰ importante ter em mente que a mensagem do commit Ã© uma forma de documentaÃ§Ã£o do histÃ³rico das mudanÃ§as que ocorreram ao longo do cÃ³digo. A pessoa que ler essa mensagem pode nÃ£o ter conhecimento do contexto original. Assim, garanta que suas mensagens de commit tenham clareza e sejam suficientemente descritivas.

Um commit deve ser realizado sempre que vocÃªÂ **finalizar uma tarefa**Â especÃ­fica ouÂ **resolver algum bug**. Isso mantÃ©m o histÃ³rico de commits claro e rastreÃ¡vel, de modo que seja possÃ­vel entender o que foi feito em cada commit.

Assim, Ã© importante realizar commits frequentemente. PorÃ©m, evite realizar commits muito pequenos ou muito grandes, pois isso pode tornar difÃ­cil o seu entendimento.

Lembre-se deÂ **nunca realizar um commit de um cÃ³digo que vocÃª sabe que contÃ©m bugs**. O ideal Ã© que o commit contenha somente cÃ³digo funcional.

O controle de mudanÃ§as do Git Ã© feito atravÃ©s dosÂ **commits**. Cada commit armazena oÂ **estado completo**Â do projeto em um determinado momento por meio de umÂ **snapshot**. Ou seja, cada commit Ã© um registro completo do repositÃ³rio no momento em que esse commit foi criado.

Cada commit possui por padrÃ£o um autor, que Ã© a pessoa que realizou aquelas alteraÃ§Ãµes no cÃ³digo.

Entretanto, quando trabalhamos em equipe pode ser que algum trecho de cÃ³digo seja escrito em dupla ou trio. Assim, como definir a autoria dessas outras pessoas no commit?

O Git oferece a possibilidade de adicionarÂ **mais de um autor**Â a um commit. Para isso, apÃ³s escrever a mensagem do commit, pulamos duas linhas e usamos a palavra-chaveÂ `Co-authored-by:`, seguido do nome e e-mail associado ao GitHub (entre < >) de cada pessoa colaboradora.

Cada coautor deve estar em uma linha diferente, como Ã© mostrado no exemplo a seguir:

```perl
$ git commit -m "Adicionar nova funcionalidade.
>
>
Co-authored-by: NOME <nome@email.com>
Co-authored-by: OUTRO-NOME <outro@email.com>"
COPIAR CÃ“DIGO
```

Caso queira entender mais sobre coautoria no GitHub, vocÃª pode acessar aÂ [documentaÃ§Ã£o referente ao assunto](https://docs.github.com/pt/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors).

---

## Git remote:

Usado para unificar bifurcaÃ§Ãµes entre os repositÃ³rios 

1. **`git remote add <name> <url>`** Ã© um comando no Git usado para adicionar um novo repositÃ³rio remoto Ã  sua configuraÃ§Ã£o local do Git. Aqui estÃ¡ uma explicaÃ§Ã£o detalhada:
    1. **`git remote`**: Este Ã© o comando utilizado para lidar com repositÃ³rios remotos no Git.
    2. **`add`**: Indica que vocÃª estÃ¡ adicionando um novo repositÃ³rio remoto Ã  sua configuraÃ§Ã£o local.
    3. **`<name>`**: Ã‰ o nome que vocÃª deseja atribuir a esse repositÃ³rio remoto. Geralmente, isso Ã© algo descritivo, como "origin", que Ã© um nome comum para se referir ao repositÃ³rio de onde vocÃª clonou o projeto.
    4. **`<url>`**: Ã‰ o URL do repositÃ³rio remoto que vocÃª estÃ¡ adicionando. Isso pode ser um URL HTTPS ou SSH para o repositÃ³rio remoto no qual vocÃª deseja enviar suas alteraÃ§Ãµes.
    
    Por exemplo, se vocÃª quisesse adicionar um repositÃ³rio remoto chamado "origin" com o URL "https://github.com/seu-usuario/seu-projeto.git", vocÃª usaria o seguinte comando:
    
    ```csharp
    
    git remote add origin https://github.com/thayanecperes/git-github
    
    ```
    
    Depois de executar este comando, o Git reconhecerÃ¡ o repositÃ³rio remoto com o nome "origin" e vocÃª poderÃ¡ enviar suas alteraÃ§Ãµes para ele usando comandos como **`git push origin <branch>`**.
    

```csharp
git remoteadd apelido url
COPIAR CÃ“DIGO

```

'apelido': Este Ã© um nome que vocÃª atribui ao repositÃ³rio remoto. Geralmente, se utiliza nomes descritivos, como "origin" para o repositÃ³rio principal no GitHub, mas vocÃª pode escolher nomes que faÃ§am sentido para o seu projeto.

2 - Â `git remote -v`Listar os repositÃ³rios remotos:

Para listar os repositÃ³rios remotos associados ao seu projeto local, vocÃª pode utilizar o comandoÂ `git remote -v`. Isso exibirÃ¡ uma lista de todos os repositÃ³rios remotos vinculados ao seu projeto, juntamente com suas URLs. Veja um exemplo:

```
git remote -v
COPIAR CÃ“DIGO
```

A saÃ­da serÃ¡ algo semelhante a:

```perl
origin   https://github.com/seu-usuario/seu-projeto.git (fetch)
origin   https://github.com/seu-usuario/seu-projeto.git (push)
COPIAR CÃ“DIGO
```

Essa lista Ã© Ãºtil para verificar se os repositÃ³rios remotos estÃ£o configurados corretamente. Obs: Vai aparecer duplicado mesmo, pois o Git separa a url de envio de commits (push) da url de baixar commits (fetch).

3 - Remover um repositÃ³rio remoto:

Caso vocÃª nÃ£o precise mais de um repositÃ³rio remoto especÃ­fico, pode removÃª-lo com o comandoÂ `git remote remove apelido`. Substitua 'apelido' pelo nome do repositÃ³rio remoto que deseja remover. Aqui estÃ¡ um exemplo:

```csharp
git remote remove origin
COPIAR CÃ“DIGO
```

ApÃ³s a execuÃ§Ã£o deste comando, o repositÃ³rio remoto chamado "origin" serÃ¡ desvinculado do seu projeto local.

4 - Alterar a URL de um repositÃ³rio remoto:

Ã€s vezes, Ã© necessÃ¡rio atualizar a URL de um repositÃ³rio remoto, como quando a URL do servidor do GitHub Ã© modificada ou quando vocÃª copiou a URL incorreta ao adicionar o repositÃ³rio remoto. Use o comandoÂ `git remote set-url apelido nova_url`Â para realizar essa atualizaÃ§Ã£o. Substitua 'apelido' pelo nome do repositÃ³rio remoto e 'nova_url' pela nova URL que vocÃª deseja associar a ele. Aqui estÃ¡ um exemplo:

```cpp
git remote set-url origin https://github.com/seu-usuario/seu-repositorio.git
COPIAR CÃ“DIGO
```

Isso atualizarÃ¡ a URL do repositÃ³rio remoto "origin" para a nova URL especificada.

5 - Alterar o apelido de um repositÃ³rio remoto:

Se vocÃª deseja renomear um repositÃ³rio remoto, use o comandoÂ `git remote rename apelido novo_apelido`. Substitua 'apelido' pelo nome atual do repositÃ³rio remoto e 'novo_apelido' pelo novo nome que vocÃª deseja atribuir a ele. Aqui estÃ¡ um exemplo:

```lua
git remote rename origin novo-origin
COPIAR CÃ“DIGO
```

Isso renomearÃ¡ o repositÃ³rio remoto de "origin" para "novo-origin".

Lembre-se de que o comando git remote Ã© fundamental para a gestÃ£o de conexÃµes entre seu repositÃ³rio local e repositÃ³rios remotos, permitindo a colaboraÃ§Ã£o eficiente e o controle de versÃ£o. Praticar esses comandos em seu ambiente de desenvolvimento ajudarÃ¡ a consolidar seu entendimento.

---

## Git push

O comandoÂ `git push`Â deve ser executado paraÂ **sincrnizar**Â as mudanÃ§as do repositÃ³rio local com o repositÃ³rio remoto, ou seja, quando desejamos enviar os novos commits que realizamos em nosso repositÃ³rio local para o repositÃ³rio remoto. No entanto, para garantir uma conexÃ£o segura, Ã© essencial configurar umaÂ **chave SSH**Â no computador antes de executar esse comando.

---

## Git pull

O comandoÂ `git pull`Â tem como objetivo, baixar os novos commits que outras pessoas colaboradoras do seu repositÃ³rio enviaram para o GitHub. Com isso, temos um fluxo de trabalho.

Ele funciona como o oposto doÂ `push`, jÃ¡ que puxa os commits do remoto para o local.

Para isso, alÃ©m deÂ `git pull`, na mesma linha de cÃ³digo indicamos qual Ã© o repositÃ³rio remoto do qual baixaremos esses commits, nesse caso serÃ¡ oÂ `origin`. Em seguida, passamos aÂ *branch*Â `main`, onde ele trarÃ¡ esses commits para o repositÃ³rio local.

```css
git pull originmainCOPIAR CÃ“DIGO
```

---

## **Clonando um repositÃ³rio**

git clone + url do repositorio a ser clonado.
esse comando faz o donwload do repositorio. 

```lua
git status

```

O GitHub tem essa sinalizaÃ§Ã£o pelas cores, se os arquivos modificados, mas nÃ£o foram adicionados ficam vermelhos quando sÃ£o ficam verdes.

**`git clone`** Ã© um comando utilizado para criar uma cÃ³pia local (clone) de um repositÃ³rio Git remoto. Isso permite que vocÃª obtenha uma cÃ³pia completa de todos os arquivos e histÃ³rico de commits do repositÃ³rio remoto em seu prÃ³prio computador.

A sintaxe bÃ¡sica do comando **`git clone`** Ã© a seguinte:

```php
phpCopy code
git clone <url_do_repositÃ³rio_remoto> [<diretÃ³rio_de_destino>]

```

- **`<url_do_repositÃ³rio_remoto>`** Ã© o URL do repositÃ³rio remoto que vocÃª deseja clonar.
- **`[<diretÃ³rio_de_destino>]`** Ã© o diretÃ³rio onde o repositÃ³rio serÃ¡ clonado. Se nÃ£o for especificado, o Git criarÃ¡ um diretÃ³rio com o mesmo nome do repositÃ³rio remoto.

Por exemplo, se vocÃª quiser clonar um repositÃ³rio chamado "meu-projeto" do GitHub para um diretÃ³rio chamado "meu-projeto-local", vocÃª usaria o seguinte comando:

```bash
bashCopy code
git clone https://github.com/usuario/meu-projeto.git meu-projeto-local

```

ApÃ³s a execuÃ§Ã£o deste comando, o Git criarÃ¡ uma cÃ³pia completa do repositÃ³rio "meu-projeto" e seu histÃ³rico de commits dentro do diretÃ³rio "meu-projeto-local" em seu computador.

---

## Git log

Para verificarmos se isso foi feito, podemo rodar oÂ `git log`.

```bash
`git log`
```

Quando estivermos trabalhando em um projeto e precisarmos realizar mudanÃ§as, usaremos oÂ `git status`Â para verificar os arquivos modificados.

Adicionaremos essas mudanÃ§as com o comandoÂ `git add`, depois, realizaremos um commit com oÂ `git commit`. Subiremos essas mudanÃ§as para o repositÃ³rio com oÂ `git push`Â e eventualmente, conforme outras pessoas forem colaborando com o projeto, traremos essas mudanÃ§as novamente para o computador com oÂ `git pull`.

### **Alterando a visualizaÃ§Ã£o do log**

Imagine que desejamos apenasÂ **visualizar as mensagens dosÂ *commits***, de forma simplificada. NÃ£o estamos interessados em quem foi o autor doÂ `commit`, em qualÂ *branch*Â ele estÃ¡, ou outros detalhes. NÃ£o desejamos verificar oÂ *hash*Â completo doÂ `commit`, apenas uma lista das mensagens, de forma mais compacta, linha por linha.

Para sair do comandoÂ `git log`, pressionaremos "Q". Agora, no terminal, digitaremosÂ `git log`, mas com aÂ *flag*Â `--oneline`.

```lua
git log --oneline
```

Isso nos permitirÃ¡ visualizar oÂ *log*Â deÂ *commits*Â de forma muito mais resumida.

ComÂ `git log --oneline`, teremos nosso histÃ³rico deÂ *commits*Â exibido com osÂ *hashes*Â reduzidos, mostrando apenas os primeiros caracteres doÂ *hash*. Isso jÃ¡ Ã© suficiente para identificarmos algumÂ *commit*.

No entanto, o oposto pode ocorrer. Estamos interessados em examinar o commit e suas alteraÃ§Ãµes, nÃ£o apenas sua mensagem, mas tambÃ©m seu conteÃºdo. Portanto, ao retornar ao terminal, limpamos a tela e digitamos o comandoÂ `git log -p`.

```bash
git log -p
```

Essa opÃ§Ã£oÂ `-p`Â vai nos fornecer, alÃ©m das informaÃ§Ãµes padrÃ£o, o hash completo, o autor ou autora, a data e a mensagem doÂ *commit*.

AlÃ©m disso, ele mostrarÃ¡ umÂ `diff`, que Ã© essencialmente um formato que oÂ *git*Â utiliza para exibir asÂ **alteraÃ§Ãµes**Â de umÂ *commit*Â especÃ­fico.

Vamos entender o formato dessas alteraÃ§Ãµes. Primeiramente, descemos, pressionando a tecla de seta para baixo, atÃ© a seÃ§Ã£o referente aoÂ `index.html`, nosso arquivo principal, onde a maioria das alteraÃ§Ãµes estÃ¡ ocorrendo.

Aqui, ele mostra como esse formato funciona. Ele diz que as linhas que comeÃ§am com "`-`" (`---- a/index.html`), significa que foram linhas que foramÂ **removidas**. E as linhas que comeÃ§am com "+" (`+++ b/index.html`), sÃ£o as linhasÂ **adicionadas**.

EntÃ£o, se houver alguma modificaÃ§Ã£o, uma mudanÃ§a em uma linha, veremos duas entradas nesseÂ `diff`: uma em que a linha comeÃ§a com "-" e outra em que a linha comeÃ§a com "+", indicando que trocamos uma linha por outra.

Ao analisar a saÃ­da no terminal, fechamos esse menu com os arquivos para visualizar essa saÃ­da um pouco melhor. Observamos que a linha com oÂ `h1`Â foi alterada; portanto, foi mudado de "Adivinhe" para "Descubra".Â **Esse Ã© o formato diff**.

### **Outras formas de exibiÃ§Ã£o doÂ *log***

E vÃ¡rias outras opÃ§Ãµes tambÃ©m, como oÂ `git log --graph`, que exibirÃ¡ uma linha do nossoÂ *log*, e isso serÃ¡ ainda mais Ãºtil quando falarmos um pouco sobreÂ *branches*.

Mas, essencialmente, se percorro isso atÃ© a parte em que temos umÂ `merge`, que foi feito no curso anterior, percebemos que ele representa graficamente uma linha do tempo se desviando para outro ponto e depois retornando Ã  nossa linha principal.

Note que Ã  esquerda hÃ¡ uma linha vertical, e a partir do ponto deÂ `merge`, outra linha se ramifica dessa vertical, estendendo-se atÃ© oÂ `commit`Â do Rodrigo. Isso ficarÃ¡ um pouco mais claro, mas com o uso deÂ `--graph`, conseguimos visualizar oÂ *log*Â de uma forma maisÂ **visual**.

HÃ¡ ainda uma opÃ§Ã£o interessante, que Ã© oÂ `--pretty`Â ouÂ `--format`. Ambos sÃ£o sinÃ´nimos.

```lua
git log --pretty
git log --format
COPIAR CÃ“DIGO
```

ComÂ `--format`Â ouÂ `--pretty`, podemos exibir oÂ *commit*Â da maneira que desejar. Por exemplo, utilizarmosÂ `--format=""`Â e dentro das aspas digitarÂ `%H %an`.

```perl
gitlog --format="%H %an"
COPIAR CÃ“DIG
```

### **Usando oÂ `git log --help`**

E como sabemos quais sÃ£o as opÃ§Ãµes, de onde vem esseÂ `%H`,Â `%an`? Se digitamosÂ `git log --help`, temos um manual, uma ajuda desse comando. E se digitarmosÂ `/pretty formats`Â e teclarmos "Enter".

```
/PRETTY FORMATS
COPIAR CÃ“DIGO
```

Em "*PRETTY FORMATS*", visualizamos que conseguimos escolher diversos formatos. Temos o formato deÂ *one line*,Â *short*,Â *medium*,Â *full*,Â *fuller*, e aqui conseguimos colocar coisas especÃ­ficas, um formato especÃ­fico.

> Exemplo de formato:
> 

```xml
short
commit <hash>
Author: <author>

<title line>
COPIAR CÃ“DIGO
```

OsÂ *placeholders*Â para nova linha, ou entÃ£o, por exemplo, mudar a cor para deixar esseÂ *log*Â mais legÃ­vel, bem formatado. Mas temos oÂ *hash*Â doÂ `commit`Â comÂ `%H`Â maiÃºsculo, ou oÂ *hash*Â abreviado comÂ `%h`Â minÃºsculo.

TambÃ©m temos o nome da autora ou do autor, que Ã© oÂ `%an`, ou o nome do autor comÂ `%aN`Â maiÃºsculo, o email comÂ `%ae`, a data doÂ `commit`, entÃ£oÂ `%aD`, temos diversas informaÃ§Ãµes que podemos utilizar aqui.

Portanto, se descermos nesta pÃ¡gina de documentaÃ§Ã£o, veremos que esseÂ `pretty`Â ouÂ `format`Â pode ser utilizado de forma bem ampla. Isso normalmente Ã© usado quando estamos criando algumÂ *script*, automatizando alguma coisa. EntÃ£o, no dia a dia, nÃ£o vamos utilizar tanto.

Agora, oÂ `git log --oneline`Â e oÂ `git log -p`, esses sim sÃ£o comandos bastante utilizados no dia a dia.

---

### **Git show:**

**Analisando umÂ `commit`Â especÃ­fico**

Desejamos compreender as alteraÃ§Ãµes realizadas nesteÂ *commit*Â especÃ­fico, independentemente de quem o tenha feito. Portanto, ao pressionarmos "Q", sairemos do registro (*log*) e solicitaremos aoÂ *Git*Â que nos apresente o conteÃºdo e os detalhes desseÂ *commit*.

Para isso, copiaremos oÂ *hash*Â correspondente e digitaremosÂ `git show`, seguido do respectivoÂ *hash*.

> git show {hash do commit}
> 

```sql
gitshow 2ad48c0
COPIAR CÃ“DIGO
```

O comandoÂ `git show`Â nos proporcionarÃ¡ uma exibiÃ§Ã£o semelhante aoÂ `git log -p`, porÃ©m focado apenas noÂ *commit*Â em questÃ£o, nÃ£o em todo o registro:

Observe como o comandoÂ `git show`Â Ã© bastante simples, ele exibe oÂ *diff*Â para nÃ³s. Novamente, basta pressionar "Q" para sair. Um detalhe interessante Ã© que, ao digitarmosÂ `git show --help`, podemos entender melhor como o comando funciona.

---

### **Git diff**

O comando **`git diff`** Ã© usado para exibir as diferenÃ§as entre os arquivos no diretÃ³rio de trabalho e o Ã­ndice (staging area), ou entre o Ã­ndice e o Ãºltimo commit, ou entre duas confirmaÃ§Ãµes.

A sintaxe bÃ¡sica Ã©:

```css
cssCopy code
git diff [<arquivo>]

```

Se nenhum arquivo for especificado, o comando mostrarÃ¡ as diferenÃ§as entre o diretÃ³rio de trabalho e o Ã­ndice. Se um arquivo for especificado, ele mostrarÃ¡ as diferenÃ§as desse arquivo entre o diretÃ³rio de trabalho e o Ã­ndice.

Alguns exemplos de uso comuns:

- **DiferenÃ§as entre o diretÃ³rio de trabalho e o Ã­ndice:**
    
    ```
    
    git diff
    
    ```
    
- **DiferenÃ§as entre o Ã­ndice e o Ãºltimo commit:**
    
    ```
    shCopy code
    git diff --cached
    
    ```
    
- **DiferenÃ§as entre o diretÃ³rio de trabalho e o Ãºltimo commit:**
    
    ```
    shCopy code
    git diff HEAD
    
    ```
    
- **DiferenÃ§as em um arquivo especÃ­fico:**
    
    ```
    shCopy code
    git diff nome_do_arquivo
    
    ```
    

O **`git diff`** mostra as diferenÃ§as de linha a linha entre os arquivos. As linhas marcadas com **`-`** indicam linhas removidas e as linhas marcadas com **`+`** indicam linhas adicionadas.

Se vocÃª estiver revisando as mudanÃ§as antes de fazer um commit, **`git diff`** pode ser muito Ãºtil para ver exatamente o que foi alterado nos seus arquivos.

## **ConclusÃ£o**

Agora, uma observaÃ§Ã£o interessante: se estivermos no meio de uma ediÃ§Ã£o, realizando alteraÃ§Ãµes, mas ainda nÃ£o fizemos o registro de alteraÃ§Ãµes? E queremos visualizar o que jÃ¡ foi alterado, o que estÃ¡ pronto para ser registrado.

Como podemos fazer isso? Como podemos ver as diferenÃ§as (diff) dos arquivos que ainda nÃ£o foram incluÃ­dos no registro de alteraÃ§Ãµes (commit)?

Para analisar a diferenÃ§a entre esses doisÂ *commits*Â especÃ­ficos, precisamos incluir os trÃªsÂ *commits*Â em nossa anÃ¡lise. Podemos fazer isso utilizando o comandoÂ `git diff`.

Primeiro, copiamos oÂ *hash*Â doÂ *commit*Â mais antigo que desejamos comparar, que Ã© o "deixando o jogo mais fÃ¡cil", e depois colamos esseÂ *hash*Â seguido de "`..`":Â `git diff 5880fc1..`. Em seguida, copiamos oÂ *hash*Â doÂ *commit*Â mais recente que queremos comparar, que Ã© o "deixando o jogo mais fÃ¡cil ainda", e o colamos apÃ³s "..".

Agora Ã© hora de compreender o significado deÂ *branch*, assim como o que representa essa referÃªncia Ã Â `main`Â quando executamosÂ `git status`. Portanto, primeiro realizaremos umÂ `git push origin main`Â e, em seguida, no prÃ³ximo vÃ­deo, nos aprofundaremos no entendimento do conceito deÂ *branch*.

1 - Para comeÃ§ar a explorar os comandos que exibem a visualizaÃ§Ã£o de alteraÃ§Ãµes no projeto, utilize o comandoÂ `git log`Â com os seguintes parÃ¢metros:

- a)Â `p`Â para visualizar as alteraÃ§Ãµes em cada arquivo modificado;
- b)Â `-oneline`Â para visualizar cada commit de forma resumida em uma Ãºnica linha;
- c)Â `-graph`Â para visualizar a linha do tempo dos commits com suas ramificaÃ§Ãµes;
- d)Â `-pretty`Â ouÂ `-format`Â para especificar com detalhes o que serÃ¡ exibido.

2 - Na sequÃªncia, executeÂ `git show`Â para visualizar o trabalho realizado em algum commit especÃ­fico. Lembre-se que se nÃ£o for informado algum commit, o Ãºltimo commit serÃ¡ exibido.

3 - Por fim, comÂ `git diff`, exiba a diferenÃ§a entre 2 pontos da linha do tempo de nosso repositÃ³rio. Caso nenhum parÃ¢metro seja passado para o comando, a diferenÃ§a exibida serÃ¡ entre o Ãºltimo commit e o que ainda nÃ£o foi adicionado comÂ `git add`.

- Aprendemos sobre parÃ¢metros adicionais doÂ `git log`Â para alterar sua forma de exibiÃ§Ã£o;
- Conhecemos o comandoÂ `git show`, que nos exibe os detalhes de um commit especÃ­fico;
- Utilizamos o comandoÂ `git diff`Â para visualizar as diferenÃ§as entre dois pontos no histÃ³rico de nosso repositÃ³rio git.

entendemos como trabalhar mais comÂ *log*, visualizar os detalhes deÂ *commit*Â comÂ `show`, e as diferenÃ§as entre dois estados comÂ `diff`. Agora falaremos sobreÂ **colaboraÃ§Ã£o**Â e como organizamos o trabalho colaborativo.

---

## Git e a IDE VSCode

Quando estamos trabalhando em um projeto utilizando o versionamento Git e a IDE VSCode, ao adicionar ou alterar algum arquivo aparece uma sinalizaÃ§Ã£o ao lado do nome desses arquivos no VSCode, como podemos ver na imagem abaixo:

!https://cdn1.gnarususercontent.com.br/1/1221554/5afdb0f3-f5cc-46b3-88f6-0062f51cbc0c.png

Mas o que isso significa?

- **M**: A letra M representa o estadoÂ *Modified*, do portuguÃªs modificado. Isso significa que o arquivo jÃ¡ existia no repositÃ³rio, mas que recebeu alguma modificaÃ§Ã£o que ainda nÃ£o foi registrada no Git.
- **U**: A letra U representa o estadoÂ *Untracked*, do portuguÃªs nÃ£o rastreado. Isso significa que o arquivo ainda nÃ£o existia no repositÃ³rio e que ainda nÃ£o teve seu registro (commit) feito no Git.

Essa sinalizaÃ§Ã£o nos ajuda a entender o estado atual dos nossos arquivos do projeto no versionamento Git.

---

---

---

# [Git e GitHub: compartilhando e colaborando em projetos](https://cursos.alura.com.br/course/git-github-compartilhando-colaborando-projetos)

## **Problemas ao colaborar**

Queremos levantar um ponto para vocÃª: se realizamos, por exemplo, umÂ `push`Â que gerou erro na aula anterior, Ã© porque utilizamos o usuÃ¡rio de trabalho e nÃ£o o usuÃ¡rio pessoal. Com o usuÃ¡rio correto selecionado, fizemos oÂ `push`Â novamente.

```
git push origin main
```

Agora vamos executar o comando abaixo:

```
git log --graph
```

Comentamos que existe uma linha, e em alguns momentos, pode existir umaÂ **bifurcaÃ§Ã£o**Â nessa linha. Vamos entender o que Ã© essa bifurcaÃ§Ã£o?

### **Simulando um cenÃ¡rio**

Imagine um cenÃ¡rio mais prÃ³ximo da realidade, onde trabalhamos em um projeto real, grande, com vÃ¡rios arquivos, funcionalidades e uma equipe com diversas pessoas, e nesse trabalho, alteramos alguns arquivos. Para simular esse caso, vamos abrir outro terminal e fazer oÂ `git clone`Â do projeto:

```
git clone git@github.com:CViniciusSDias/numero-secreto.git
```

Em seguida, vamos acessar o projetoÂ `numero-secreto`Â em outro lugar:

```
cd numero-secreto/
COPIAR CÃ“DIGO
```

Ou seja, estamos fora doÂ *Visual Studio Code*, em um terminal em outro local, e vamos abrir o arquivoÂ `index.html`Â no ambiente diferente de outro editor para modificÃ¡-lo.

```
vim index.html
COPIAR CÃ“DIGO
```

Feito isso, vamos remover o "em" do tÃ­tulo "Jogo em JS"; serÃ¡ somente "Jogo JS".

> index.html:
> 

```html
<title>Jogo JS</title>
COPIAR CÃ“DIGO
```

Uma vez salvo o arquivo, podemos executar o comandoÂ `git status`. AlÃ©m disso, com o comandoÂ `git diff`, conseguimos visualizar o que foi alterado.

```
git status
```

```
git diff

```

Agora vamos adicionar o arquivoÂ `index.html`, e na sequÃªncia, adicionaremos umÂ `commit`Â chamado "Removendo palavra do tÃ­tulo". ApÃ³s oÂ `commit`, faremos oÂ `push`Â para aÂ `origin main`.

```
git add index.html
```

```
git commit -m "Removendo palavra do tÃ­tulo"
```

```
git push origin main
```

Imagine que isso foi feito por uma pessoa que trabalha conosco, ou seja, outra pessoa fez oÂ `commit`, oÂ `push`, e estÃ¡ agora no repositÃ³rio. NÃ³s, ao mesmo tempo, trabalhamos em outra funcionalidade, como, por exemplo, corrigir o acento da palavra "nÃºmero" na tagÂ `<h1>`Â da linha 22.

> index.html:
> 

```html
<h1>Descubra o <span class="container__texto-azul">nÃºmero secreto</span></h1>
```

ApÃ³s fazer a alteraÃ§Ã£o, vamos abrir o terminal no Visual Studio Code, executar o comandoÂ `git diff`Â para garantir que estÃ¡ tudo certo e que vamos comitar corretamente. Novamente, vamos adicionar oÂ `index.html`, e adicionar oÂ `commit`Â com a mensagem "Adicionando acento".

```
git commit -m "Adicionando acento"
```

Fizemos oÂ `commit`, mas agora, quando formos fazer oÂ `git push origin main`, o Git vai rejeitar esseÂ `push`, dizendo que existem atualizaÃ§Ãµes feitas que ainda nÃ£o estÃ£o no cÃ³digo.

Isso Ã© um "problema" que jÃ¡ conhecemos antes, entÃ£o o que precisa ser feito? Primeiro, precisamos fazer umÂ `git pull`. Com isso, ele vai trazer as alteraÃ§Ãµes e fazer o que ele chama deÂ ***merge***.

> Entenderemos melhor sobre merge em breve.
> 

```
git pull
```

Vamos aceitar esse merge. No nosso editor, basta executar o comandoÂ `:x`Â para salvar. Assim, fizemos o merge e agora podemos fazer oÂ `push`Â doÂ `origin main`, ou seja, eleÂ **buscou as alteraÃ§Ãµes**Â que estavam no repositÃ³rio,Â **mesclou**Â com as nossas (significado de "merge"), e agora temos oÂ **repositÃ³rio atualizado**. Com o repositÃ³rio atualizado, podemos enviar as alteraÃ§Ãµes.

PorÃ©m, jÃ¡ abordamos tudo isso no curso anterior e vocÃª jÃ¡ passou por esse problema. Tanto que, se fizermosÂ `git log --graph`, temos exatamente o cenÃ¡rio de bifurcaÃ§Ã£o que jÃ¡ vimos anteriormente.

```
git log --graph
```

Por que mostramos isso de novo? Porque, novamente, pensando em um cenÃ¡rio colaborativo, imagine uma equipe pequena, com 10 pessoas. Imagine um projeto pequeno, com 1.000 arquivos.

Isso, em uma escala de mundo real, sÃ£o coisas pequenas; uma equipe de 10 pessoas Ã© pequena, da mesma forma que um projeto com 1.000 arquivos Ã© pequeno. Imagine ter que lidar com essa situaÃ§Ã£o toda vez que alteramos algum desses 1.000 arquivos para cada uma dessas 10 pessoas.

Toda hora terÃ¡ alguÃ©m enviando modificaÃ§Ã£o para o repositÃ³rio, porque a cada alteraÃ§Ã£o que fazemos no projeto, executamos umÂ `commit`Â e enviamos essa alteraÃ§Ã£o, para garantir que, caso nosso computador dÃª problema, nada seja perdido.

HÃ¡ ainda outro ponto: imagine que estamos fazendo uma alteraÃ§Ã£o e estamos no processo de tornar a nossa aplicaÃ§Ã£o como um todoÂ **gramaticalmente correta**, entÃ£o adicionamos o acento em "nÃºmero", temos que verificar outros arquivos que provavelmente tÃªm a palavra "nÃºmero" sem acento, e assim por diante.

Com isso, podemos ter vÃ¡rios commits nessa funcionalidade, isto Ã©, uma Ãºnica funcionalidade pode conter vÃ¡rios commits.

Imagine que corrigimos a palavra "nÃºmero" e fizemos oÂ `push`Â para enviar a alteraÃ§Ã£o para o repositÃ³rio remoto. Assim, todas as pessoas que utilizarem esse repositÃ³rio, irÃ£o visualizar a alteraÃ§Ã£o no meio do caminho. Ainda nÃ£o terminamos a funcionalidade, mas ela jÃ¡ estÃ¡ no repositÃ³rio remoto para todos verem.

Imagine que queremos colocar isso em produÃ§Ã£o. Sempre que vamos colocar um cÃ³digo em produÃ§Ã£o e disponibilizar efetivamente esse projeto para o mundo ver, ele deve estar pronto, no estado completo.

Portanto, se estamos no meio de uma alteraÃ§Ã£o, nÃ£o podemos fazer oÂ ***deploy***Â (implantaÃ§Ã£o), nÃ£o podemos colocar esse projeto no ar.

Sendo assim, alguÃ©m que desenvolvia outra funcionalidade, agora precisarÃ¡ nos esperar terminar essa funcionalidade para colocar a dela no ar, porque tambÃ©m enviamos metade de uma alteraÃ§Ã£o.

https://git-school.github.io/visualizing-git/

---

## **Git Branch**

**Ramificando o trabalho**

Temos nosso projeto desenvolvido e queremos comeÃ§ar a trabalhar em outra funcionalidade. Para isso, podemos criar umaÂ **ramificaÃ§Ã£o**, um galho na nossa Ã¡rvore. Isso Ã© o que chamamos deÂ ***branch***.

Se digitarmos o comandoÂ `git branch`Â no Visualizing Git, ele vai mostrar quais sÃ£o as branches, isto Ã©, quais sÃ£o as ramificaÃ§Ãµes existentes no nosso trabalho.

```
git branch
COPIAR CÃ“DIGO
```

Por padrÃ£o, sÃ³ temos a branchÂ `main`, que o Visualizing Git chama deÂ `master`. Antigamente, a branch principal se chamavaÂ `master`, mas essa nomenclatura padrÃ£o foi alterada paraÂ `main`. Sendo assim, hoje em dia, a branch padrÃ£o se chamaÂ `main`.

Se quisermosÂ **renomear**Â aÂ `master`Â paraÂ `main`, usamos o comando abaixo:

```
git branch -m master main
COPIAR CÃ“DIGO
```

Se quisermosÂ **remover**Â alguma branch, caso tenhamos uma lista de vÃ¡rias branches, podemos usar o comandoÂ `git branch -d`Â seguido do nome da branch que queremos remover. Por exemplo:

```
git branch -d master
COPIAR CÃ“DIGO
```

### **Criando uma nova ramificaÃ§Ã£o**

Em vez de renomear ou remover, queremosÂ **criar uma nova ramificaÃ§Ã£o**, ou seja, uma nova linha de trabalho, para que possamos criar essa nossa nova funcionalidade.

Vamos chamar essa nova linha de trabalho deÂ `gramatica`. Para isso, basta digitar o comandoÂ `git branch`Â seguido do nome do ramo que queremos trabalhar. Esse ramo, ou seja, essa branch serÃ¡ criada sem espaÃ§o, maiÃºsculas e acentos, porque Ã© uma identificaÃ§Ã£o de algo.

```
git branch gramatica

```

Agora, se fizermos um novoÂ `commit`, ele serÃ¡ feito na branchÂ `master`, onde estamos no momento, ou na branchÂ `gramatica`? Vamos fazer esseÂ `commit`Â com a mensagem "Onde estou".

```
git commit -m "Onde estou"

```

Perceba que foi feito oÂ `commit`Â na branchÂ `master`. NÃ£o fizemos na branchÂ `gramatica`, porque o local de trabalho do projeto estÃ¡ na branchÂ `master`. Se quisermos modificar a branch atual para outra, precisamos de algum comando, e existem alguns para isso.

---

### **Git checkout**

**Alternando entreÂ *branches***

Primeiro, vamos mostrar um comando antigo, depois falamos sobre o mais novo. Inicialmente, digitaremos um comando chamadoÂ `git checkout`. O comandoÂ `git checkout`Â faz um monte de coisa. Nesse caso, se passarmos o nome de uma branch, ele vai alterar onde estamos.

```
git checkout gramatica

```

Ao fazer isso, repare que oÂ `HEAD`Â muda de lugar e vai para baixo da branchÂ `gramatica`. Isso indica que agora estamos na branchÂ `gramatica`, trabalhando a partir desse commit.

Sendo assim, se fizermos umÂ `commit`Â com a mensagem "Agora na branch certa", por exemplo, visualizaremos uma ramificaÃ§Ã£o no nosso trabalho.

```
git commit -m "Agora na branch certa"
```

Agora, hÃ¡ duas linhas de trabalho diferentes eÂ **independentes**. Portanto, podemos executar o comandoÂ `branch -d master`Â para remover a branchÂ `master`Â se quisermos.

```
git branch -d master
```

Feito isso, a branchÂ `master`Â nÃ£o existirÃ¡ mais. Podemos fazer oÂ `git checkout`Â para a branchÂ `main`Â e adicionar alguns commits com o comandoÂ `git commit`Â sem mensagem.

```
git checkout main
```

```
git commit
```

Repare que temos, novamente, duas linhas de trabalho diferentes. Ã‰ isso que o comandoÂ `git log --graph`Â mostrou para nÃ³s anteriormente: aÂ **ramificaÃ§Ã£o**Â no nosso trabalho. Depois, podemos mesclar isso.

### **Criando ramificaÃ§Ãµes no projeto**

Agora que entendemos como funciona o processo no Visualizing Git, vamos fazer o mesmo no projeto real. Com oÂ *VS Code*Â aberto, vamos acessar o terminal.

Se digitarmos o comandoÂ `git branch`, ele vai retornar que sÃ³ temos a branchÂ `main`:

```
git branch
```

PoderÃ­amos usar o comandoÂ `git branch`Â seguido de uma nova branch que quisermos, referente a qualquer nova funcionalidade. PorÃ©m, se quisermos criar uma branch e jÃ¡ mover para ela, podemos usar dois comandos. O primeiro Ã© oÂ `git checkout -b`Â seguido do nome da nova branchÂ `nova-funcionalidade`.

```
git checkout -b nova-funcionalidade
```

---

## Git switch

AlÃ©m desse comando mais antigo, podemos utilizar oÂ `git switch`, tambÃ©m seguido do nome da branch desejada. "*Switch*" significaÂ **trocar**, ou seja, esse comando basicamente alterna entre branches.

PorÃ©m, se digitarmos simplesmenteÂ `git switch nova-funcionalidade`, serÃ¡ informado que essa branch nÃ£o existe. EntÃ£o, vamos executarÂ `git switch -c nova-funcionalidade`Â (`-c`Â referente a "*create*").

```
git switch -c nova-funcionalidade
```

Agora temos uma nova ramificaÃ§Ã£o do nosso trabalho. Podemos fechar o terminal e adicionar alguma modificaÃ§Ã£o no cÃ³digo do arquivoÂ `index.html`. Por exemplo: vamos adicionar uma quebra de linha na imagem (`<img>`) da linha 32, logo antes dos atributosÂ `alt`Â eÂ `class`.

```html
<img src="./img/ia.png"
     alt="Uma pessoa olhando para a esquerda"
     class="container__imagem-pessoa" />
```

Essa Ã© a nova funcionalidade que desenvolvemos, com alteraÃ§Ãµes no cÃ³digo. Agora vamos abrir o terminal novamente e executar o comandoÂ `git status`.

```
git status
COPIAR CÃ“DIGO
```

Com isso, ele mostra que estamos na branchÂ `nova-funcionalidade`. Vamos adicionar o arquivoÂ `index.html`Â com o comandoÂ `git add`, e depois adicionar umÂ `commit`Â com a mensagem "Quebrando linha na imagem".

```
git add index.html
```

```
git commit -m "Quebrando linha na imagem"
```

Se fizermos umÂ `git log`Â agora, temos um retorno um pouco diferente.

```
git log
```

Temos o commit anterior, doÂ *merge*Â na branchÂ `main`; temos oÂ `origin/main`; agora o Ãºltimo commit Ã© onde estÃ¡ oÂ `HEAD`Â atual; e temos a branchÂ `nova-funcionalidade`. Repare que a branchÂ `nova-funcionalidade`Â ainda nÃ£o foi para oÂ `origin`, pois nÃ£o enviamos.

PorÃ©m, antes de enviar, vamos fazer umÂ `switch`Â e voltar para branchÂ `main`:

```
git switch main
```

A funcionalidade que estamos desenvolvendo estÃ¡ nessa branch, isto Ã©, o commit existe nela, nÃ£o descartamos ele. PorÃ©m, voltamos a trabalhar na linha de trabalho principalÂ `main`.

Portanto, se fechamos o terminal e acessamos a tag de imagem que alteramos no cÃ³digo, ela estarÃ¡ sem quebra de linha. Se voltarmos para o terminal e executarmosÂ `git log`, oÂ `head`Â terÃ¡ voltado paraÂ `main`. EntÃ£o, oÂ `HEAD`Â Ã© onde estamos no momento, Ã© o commit atual onde o nosso projeto estÃ¡.

Dito isso, vamos fazer umÂ `git switch`Â paraÂ `nova-funcionalidade`:

```
git switch nova-funcionalidade
```

Mais uma vez, o cÃ³digo aparecerÃ¡ atualizado com a quebra de linha que adicionamos. Assim, podemos fazer oÂ `git push`Â para o repositÃ³rio remoto, ou seja,Â `origin`Â da branchÂ `nova-funcionalidade`.

```
git push origin nova-funcionalidade

```

ApÃ³s teclar "Enter", a nova ramificaÃ§Ã£o serÃ¡ criada e teremos uma nova linha de trabalho.

Note que fizemos oÂ `push`Â deÂ `nova-funcionalidade`, e noÂ *GitHub*, ele exibe uma mensagem que indica que podemos criar umaÂ ***pull request***Â a partir da nossa nova branch.

O GitHub jÃ¡ identificou que existe uma nova branch e que, em algum momento, vamos quererÂ **unir**Â a branchÂ `nova-funcionalidade`Â com aÂ `main`, que Ã© a branch principal.

> Vamos deixar umÂ Para saber maisÂ sobre pull requests quando colaboramos, por exemplo, em um projetoÂ open sourceÂ (de cÃ³digo aberto), ou atÃ© se colaboramos com uma equipe que utiliza GitHub.
> 

Basicamente, queremos unir o trabalho da branchÂ `nova-funcionalidade`Â Ã  branchÂ `main`.

---

## **Unindo as ramificaÃ§Ãµes**

NÃ£o precisamos utilizar o GitHub para esse objetivo, entÃ£o vamos acessar oÂ *[Visualizing Git](https://git-school.github.io/visualizing-git/)*.

 Em uma nova linha de trabalho, vamos adicionar doisÂ *commits*Â com o comandoÂ `git commit`, criar a branchÂ `nova-funcionalidade`Â com o comandoÂ `git checkout -b`, e adicionar mais dois commits a essa nova branch.

```
git commit
```

```
git checkout -b nova-funcionalidade
```

Em seguida, vamos fazer umÂ `git switch`Â para a branchÂ `master`:

```
git switch master
```

---

## Git merge

Queremos pegar tudo o que foi feito emÂ `nova-funcionalidade`Â e trazer para o ramo principalÂ `master`. Existe um comando que faz isso de forma bastante simples: oÂ `git merge`Â ("mesclar" em inglÃªs).

VocÃª se lembra que quando fizemos oÂ `pull`Â e oÂ `push`Â com dois usuÃ¡rios diferentes, chegamos nesse cenÃ¡rio deÂ ***merge***, isto Ã©, deÂ **mescla de trabalhos**? Podemos fazer isso ativamente.

Podemos dizer que estamos na branchÂ `main`, a branch principal, pegar tudo o que tem na branchÂ `nova-funcionalidade`Â e mesclar com o que jÃ¡ temos naÂ `main`.

Se fizermos oÂ `merge`Â deÂ `nova-funcionalidade`, ele vai levar aÂ `main`Â para o mesmo local.

```
git merge nova-funcionalidade

```

---

### **O que Ã©Â *fast forward*?**

Existem algumas formas doÂ `merge`Â ser feito. Nesse caso, ele executou o que Ã© chamado deÂ ***fast forward***Â (mover adiante). AtÃ© o ponto daÂ `nova-funcionalidade`Â ser criada, aÂ `master`Â estava no terceiro commit. A partir desse ponto, criamos uma nova branch, e a branchÂ `nova-funcionalidade`Â evoluiu na mesma linha, sem que aÂ `master`Â tivesse novos commits.

EntÃ£o, na hora de fazer oÂ `merge`, Ã© muito simples: nÃ£o precisamos criar nenhum novo commit; o Git entende tudo e sÃ³ move as coisas. Se queremos unir as coisas, a partir de agora, a branch principal estarÃ¡ no mesmo ponto que aÂ `nova-funcionalidade`. Isso Ã© o chamado fast forward.

Vamos fazer isso no terminal doÂ *Visual Studio Code*. ComeÃ§aremos fazendo oÂ `git switch`Â para a branch principalÂ `main`, e faremos umÂ `merge`Â comÂ `nova-funcionalidade`.

```
git switch main

```

```
git merge nova-funcionalidade

```

Com isso, ele farÃ¡ exatamente o que dissemos: o fast forward. Isso quer dizer que ele nÃ£o cria um novo commit, nem faz nada de diferente; ele simplesmente diz que, a partir de agora, a branchÂ `main`Â estÃ¡ no mesmo lugar que a branchÂ `nova-funcionalidade`.

Se executarmos o comandoÂ `git log --graph`, notaremos que nÃ£o precisamos de uma nova ramificaÃ§Ã£o.

```
git log --graph

```

### **Realizando alteraÃ§Ãµes**

Vamos voltar para a branchÂ `nova-funcionalidade`Â e alterar algo no cÃ³digo.

```
git switch nova-funcionalidade
```

Podemos acessar o arquivoÂ `README.md`, por exemplo, e fazer alguma alteraÃ§Ã£o simples. Nesse caso, vamos adicionar uma quebra de linha entre cada uma das imagens a partir da linha 8.

> README.md:
> 

```markdown
## ğŸš€ Tecnologias<div><img src="https://img.shields.io/badge/HTML-239120?style=for-the-badge&logo=html5&logoColor=white"><img src="https://img.shields.io/badge/CSS-239120?&style=for-the-badge&logo=css3&logoColor=white"><img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"></div>COPIAR CÃ“DIGO
```

Novamente, o comandoÂ `git status`Â vai nos mostrar que estamos na branchÂ `nova-funcionalidade`:

```
git status
```

Vamos adicionar o arquivoÂ `README.md`Â com o comandoÂ `git add`Â e, na sequÃªncia, adicionar um novoÂ `commit`Â com a mensagem "Quebra de linha entre imagens". Podemos atÃ© fazer oÂ `git push`Â deÂ `nova-funcionalidade`Â para ir ao repositÃ³rio remoto.

```
git add README.md
```

```
git commit -m "Quebra de linha entre imagens"
```

```
git push origin nova-funcionalidade
```

Feito isso, vamos voltar para a branchÂ `main`.

```
git switch main
```

Imagine que outras funcionalidades estÃ£o acontecendo e outras pessoas estÃ£o desenvolvendo. Dito isso, vamos ao arquivoÂ `style.css`, por exemplo, e mudaremos a propriedadeÂ `font-size`Â da tagÂ `h1`Â deÂ `50px`Â paraÂ `51px`, dentro doÂ `@media screen`Â na linha 116.

> style.css:
> 

```css
@media screenand (max-width: 1250px) {

h1 {
        font-size: 51px;
    }
COPIAR CÃ“DIGO
```

Ã‰ isso que vai acontecer: vamos adicionar o arquivo de estilo com o comandoÂ `git add`, e a mensagem doÂ `commit`Â serÃ¡ "Aumentando a fonte".

```
git add style.css
```

```
git commit -m "Aumentando a fonte"
```

Agora, se executarmos o comandoÂ `git log`, temos o commit "Aumentando a fonte". Se alternarmos para a branchÂ `nova-funcionalidade`Â comÂ `git switch`, e executarmos novamenteÂ `git log`Â para verificar o que temos emÂ `nova-funcionalidade`, o commit "Aumentando a fonte" nÃ£o farÃ¡ parte dessa linha de trabalho.

### **Fazendo umÂ *merge commit***

Estamos no cenÃ¡rio onde as duas branches evoluÃ­ram de formaÂ **independente**. Este Ã© o cenÃ¡rio mais comum: trabalhamos na branch de alguma funcionalidade, e outras funcionalidades foram adicionadas Ã Â `main`, outras coisas foram feitas e jÃ¡ estÃ£o na linha de trabalho principal.

Sendo assim, quando fizermos umÂ `git switch`Â paraÂ `main`Â e tentarmos fazer umÂ `git merge`Â deÂ `nova-funcionalidade`, o Git vai entender que esses dois trabalhos estÃ£o independentes e nÃ£o evoluÃ­ram de forma igual. Dessa forma, ele irÃ¡ unir criando um novo commit automaticamente. Ele criarÃ¡ um novo commit de merge, ouÂ ***merge commit***, como normalmente Ã© chamado nas documentaÃ§Ãµes.

```
git switch main
```

```
git merge nova-funcionalidade
```

Com esses comandos, serÃ¡ aberto um editor que permite a alteraÃ§Ã£o da mensagem de commit de merge. No nosso caso, vamos deixar o commit como estÃ¡.

Como o editor Ã© o VI, basta executarÂ `:x`Â para salvar e sair. Ao final, teremos um novo commit criado. Se executarmos o comandoÂ `git log --graph`, podemos observar o que acontece naÂ `main`.

Primeiramente, temos o commit "Quebrando linha na imagem". Depois ele cria uma nova linha de trabalho, onde temos o commit "Aumentando a fonte". Na sequÃªncia, temos "Quebra de linha entre imagens", e por Ãºltimo o merge commit, isto Ã©, o commit deÂ **mescla**.

Reparem que bifurcamos o nosso trabalho e depois unimos. Lembrando que tudo isso Ã© feito automaticamente pelo Git, mas Ã© importante entender que existem essas duas estratÃ©gias: deÂ **fast forward**Â e de criaÃ§Ã£o doÂ **merge commit**.

Dessa forma, conseguimos unir trabalho de duas branches diferentes para ter tudo na linha principal. Agora a nossa linha principal possui toda aÂ `nova-funcionalidade`. O ramoÂ `nova-funcionalidade`Â foi completo, unimos Ã  linha principal, entÃ£o agora podemos fazerÂ ***deploy***Â da nossa aplicaÃ§Ã£o.

### **Ajustes finais**

Para finalizar, vamos executar o comandoÂ `git push origin main`Â para atualizar aÂ `main`Â com todo o trabalho novo. Em seguida, removeremos a branchÂ `nova-funcionalidade`Â comÂ `git branch -d`, para manter o projeto limpo e sem excesso de branches.

```
git push origin main
COPIAR CÃ“DIGO
```

```
git branch -d nova-funcionalidade
COPIAR CÃ“DIGO
```

Ainda podemos remover a branchÂ `nova-funcionalidade`Â do repositÃ³rio remoto no GitHub. Para isso, executamos o seguinte comando:

```
git push origin :nova-funcionalidade
COPIAR CÃ“DIGO
```

> Os dois pontos (:) indicam que estamos removendo no repositÃ³rio remoto.
> 

O GitHub possui uma funcionalidade chamadaÂ *Pull requests*, que Ã© uma sugestÃ£o de alteraÃ§Ã£o em determinado repositÃ³rio. Outras ferramentas, como o GitLab, podem chamar essa mesma ferramenta deÂ *Merge requests*.

Essa sugestÃ£o de alteraÃ§Ã£o Ã©, de forma resumida, a abordagem que adotamos ao colaborar com equipes para adicionar novas funcionalidades ou corrigir alteraÃ§Ãµes. Ao invÃ©s de manualmente mesclarmos o cÃ³digo de nossaÂ *branch*Â com aÂ *main*, nÃ³s criamos umÂ *pull request*Â (ouÂ *merge request*), pois dessa forma a alteraÃ§Ã£o fica mais visÃ­vel para toda a equipe e permite que outras pessoas possam revisar esse trabalho.

HÃ¡ muitas outras funcionalidades emÂ *pull requests*, mas essa explicaÃ§Ã£o jÃ¡ Ã© um bom comeÃ§o. Se vocÃª quiser ver umÂ *pull request*Â na prÃ¡tica para um projeto de cÃ³digo aberto, no vÃ­deoÂ **Contribuindo para projetos open source - Criando um pull request real no GitHub**Â eu mostro exatamente isso.

# **Atualizando a branch**

NoÂ *Visualizing Git*, encontramos o cenÃ¡rio que reproduzimos na Ãºltima aula.

!https://cdn1.gnarususercontent.com.br/1/795715/7aacfa0d-a8b8-4cce-a7da-9b49c8556fef.png

Temos aÂ *branch*Â principal, ramificamos uma nova funcionalidade, criamos doisÂ *commits*Â e depois fizemos umÂ *merge*, ou seja, um novoÂ *commit*Â foi criado com a junÃ§Ã£o desses dois trabalhos. Basicamente, Ã© isso que fazemos quando temos umÂ *merge*, quando temos dois trabalhos bifurcados.

Agora, criaremos um novo cenÃ¡rio. EntÃ£o, rodamos o comandoÂ `clear`Â para limpar oÂ *Visualizing Git*.

```css
clear
COPIAR CÃ“DIGO
```

Em sequencia, adicionamos uma novaÂ *branch*Â chamadaÂ `main`, entÃ£o passamosÂ `git checkout -b main`.

```css
git checkout -bmainCOPIAR CÃ“DIGO
```

Em sequÃªncia, removemos aÂ *branch*Â chamadaÂ `master`Â para jÃ¡ nos adaptarmos com os nomes corretos. EntÃ£o passamos o comandoÂ `git branch -d master`.

```
git branch -d master
COPIAR CÃ“DIGO
```

> Recapitulando, oÂ git checkoutÂ Ã© um comando antigo que faz muita coisa. Contudo, oÂ Visualizing GitÂ nÃ£o foi atualizado para ter o comandoÂ git switch. Mas, normalmente, utilizamos o comandoÂ git switch, que Ã© mais simples.
> 

Continuando, adicionaremos algunsÂ *commits*Â naÂ *branch*Â `main`, faremos isso sem mensagem, sÃ³Â *commits*Â vazios. PassamosÂ `git commit`Â duas vezes.

```sql
gitcommitCOPIAR CÃ“DIGO
```

Agora criaremos um novoÂ *branch*Â passandoÂ `git branch nova-funcionalidade`.

```
git branch nova-funcionalidade
COPIAR CÃ“DIGO
```

Criamos um novoÂ *branch*, mas ainda estamos naÂ `main`, nÃ£o naÂ `nova-funcionalidade`. ApÃ³s, adicionamos mais doisÂ *commits*Â naÂ *branch*Â `main`Â passandoÂ `git commit`.

Agora, voltamos para oÂ `git checkout nova-funcionalidade`Â para trabalharmos nela.

```
git checkout nova-funcionalidade
COPIAR CÃ“DIGO
```

Em seguida adicionamos dois commits, passando duas vezes o cÃ³digo abaixo.

```sql
gitcommitCOPIAR CÃ“DIGO
```

O cenÃ¡rio que montamos noÂ *Visualizing Git*, criamos uma novaÂ *branch*Â chamadaÂ `nova-funcionalidade`Â e estamos trabalhando nela. Enquanto trabalho nessaÂ *branch*, outras pessoas podem ter criado outrosÂ *branches*Â e jÃ¡ se uniram Ã  linha principal, Ã Â `main`. Normalmente, essaÂ `main`Â Ã© o projeto final que pode ser enviado Ã  produÃ§Ã£o. Ã‰ o projeto com todas as funcionalidades que estejam completas.

Estamos criando uma nova funcionalidade, porÃ©m queremos testÃ¡-la na versÃ£o mais recente do projeto. Repare que, a partir do momento em que criamos aÂ `nova-funcionalidade`, dois outros commits tambÃ©m foram criados, ou seja, duas funcionalidades foram adicionadas no projeto principal.

Queremos garantir que o que estamos desenvolvendo funcione, mesmo com as funcionalidades que as outras pessoas criaram. Queremos garantir que tudo se integre da forma correta.

Sendo assim, queremos fazer com que a branchÂ `nova-funcionalidade`Â nÃ£o seja criada a partir da versÃ£o antiga da branchÂ `main`e sim da versÃ£o mais nova.

Portanto, queremos reescrever a histÃ³ria, fazendo com que o primeiroÂ *commit*Â da nova funcionalidade venha logo apÃ³s do momento atual daÂ `main`Â atualizada. Queremos fazer com que aÂ *branch*Â `nova-funcionalidade`, seja reescrito para ter todas as funcionalidades daÂ `main`Â antes dela.

## Git rebase:

Isso pode ser feito com um comando mÃ¡gico chamadoÂ `git rebase`, que faz muita coisa, comoÂ **reescrever a histÃ³ria dosÂ *commits***. EntÃ£o, se estivermos emÂ `nova-funcionalidade`Â e executarmos o comandoÂ `git rebase main`, ele pegarÃ¡ todos osÂ *commits*Â daÂ `main`Â que nÃ£o estÃ£o naÂ *branch*Â `nova-funcionalidade`, e tentar adicionar um a um antes daÂ *branch*Â `nova-funcionalidade`.

```css
git rebasemain
```

Ele pegarÃ¡ o primeiroÂ *commit*Â e tentar adicionar antes doÂ *commit*Â `nova-funcionalidade`. PegarÃ¡ o prÃ³ximoÂ *commit*, que Ã© o Ãºltimo daÂ `main`, e tentar adicionar antes doÂ *commit*Â `nova-funcionalidade`. ApÃ³s isso, pega todos osÂ *commits*Â daÂ `nova-funcionalidade`Â e aplica depois do Ãºltimo daÂ `main`.

Pode parecer bastante complexo, mas se visualizarmos o que estÃ¡ acontecendo, talvez fique um pouco mais fÃ¡cil. Ele primeiro traz oÂ *head*Â para aÂ `main`Â e depois aplica tudo daÂ `nova-funcionalidade`, cada um dosÂ *commits*, depois. Vai aplicandoÂ *commit*Â aÂ *commit*Â depois da Ãºltima coisa que estiver naÂ `main`.

Recapitulando novamente. Temos duasÂ *branches*Â independentes, umaÂ `main`Â e umaÂ `nova-funcionalidade`. Se queremos garantir que essaÂ `nova-funcionalidade`Â agora tenha tudo o que tem naÂ `main`Â tambÃ©m, podemos fazer oÂ `rebase`.

OÂ `rebase`Â farÃ¡ o quÃª? Se estamos naÂ `nova-funcionalidade`Â e tentamos fazer oÂ `rebase`Â com aÂ `main`, ele vai alterar oÂ *branch*Â para ir para aÂ `main`. Depois daÂ `main`, ele vai aplicando cada um dosÂ *commits*Â daÂ `nova-funcionalidade`. Isso Ã© feitoÂ *commit*Â porÂ *commit*, porque se tiver algum conflito em algum dosÂ *commits*, vamos resolvendo um a um. Dessa forma, conseguimos reescrever a histÃ³ria.

Reparem que agora oÂ `nova-funcionalidade`Â possui doisÂ *commits*Â comÂ *hashes*Â diferentes, porque vieram de outro lugar a partir de uma nova histÃ³ria. Vamos fazer isso, na prÃ¡tica.

Para isso, abrimos o projeto no VS Code, limpamos o terminal e passamos o comandoÂ `git status`.

```lua
git status
COPIAR CÃ“DIGO
```

Agora estamos naÂ `main`. EntÃ£o, passamos o comandoÂ `git switch -c nova-funcionalidade`. Vou criar mais umaÂ `nova-funcionalidade`.

```r
git switch -c nova-funcionalidade
COPIAR CÃ“DIGO
```

Agora, corrigiremos a indentaÃ§Ã£o do link na linha 10 para que o atributoÂ `rel`Â esteja na mesma coluna do meu atributoÂ `href`. Fizemos uma alteraÃ§Ã£o simples.

No terminal, adicionamos esseÂ *commit*. EntÃ£o, escrevemosÂ `git add index.html`.

```csharp
gitadd index.html
COPIAR CÃ“DIGO
```

Seguido deÂ `git commit -m "Corrigindo indentaÃ§Ã£o"`.

```sql
gitcommit -m "Corrigindo indentaÃ§Ã£o"
COPIAR CÃ“DIGO
```

Vamos quebrar tambÃ©m oÂ `<script>`Â para que a abertura e o fechamento dessa tag fiquem em linhas diferentes.

```xml
//CÃ³digo omitido

<script src="https://code.responsivevoice.org/responsivevoice.js">
</script>

//CÃ³digo omitido
COPIAR CÃ“DIGO
```

Feito isso, no terminal passamosÂ `git add index.html`, seguido deÂ `git commit -m "Quebrando linha do script"`.

```sql
gitcommit -m "Quebrando linha do script"
COPIAR CÃ“DIGO
```

Temos aÂ `nova-funcionalidade`Â sendo desenvolvida. Agora, faremos oÂ `git switch`Â paraÂ `main`. Imagine que alguma outra nova funcionalidade serÃ¡ adicionada no ramo principal.

Quebraremos a linha referente ao botÃ£o de chute para que o textoÂ `Chutar`Â fique separado das tags de abrir e fecharÂ `<button>`. Fazemos o mesmo emÂ `Novo Jogo`.

```jsx
//CÃ³digo omitido

    <divclass="chute container__botoes">
            <button onclick="verificarChute()" class="container__botao">
                Chutar
            </button><button onclick="reiniciarJogo()" id="reiniciar" class="container__botao" disabled>
                Novo jogo
            </button>
    </div>
</div>

//CÃ³digo omitido
COPIAR CÃ“DIGO
```

Feito isso, salvamos. No terminal, adicionamosÂ `git add index.html`, seguido doÂ `git commit -m "Indentando botÃµes"`.

```sql
gitcommit -m "Indentando botÃµes"
COPIAR CÃ“DIGO
```

NaÂ *branch*Â `main`, temos uma nova funcionalidade que indentou os botÃµes. Se fazemosÂ `git switch nova-funcionalidade`, temos a indentaÃ§Ã£o das tags no inÃ­cio do arquivo. SÃ³ que queremos garantir que o arquivoÂ `index.html`Â esteja correto mesmo se pegarmos tudo da Ãºltima versÃ£o daÂ `main`. EntÃ£o, primeiro passamos o comandoÂ `git log --`.

```lua
git log --
COPIAR CÃ“DIGO
```

Assim Ã© exibido que temosÂ `Corrigindo indentaÃ§Ã£o`, mostrando a linha doÂ *script*Â depois doÂ `origin/main`, mas nÃ£o doÂ `main/local`, pois tem umÂ *commit*Â novo. Limpamos a tela e passamos oÂ `git rebase main`.

```css
git rebasemainCOPIAR CÃ“DIGO
```

Isso faz umÂ `git switch`Â paraÂ `main`, pega cada um dosÂ *commits*Â que temos nessaÂ `nova-funcionalidade`Â e tenta aplicar a partir desse novo momento. Depois, move novoÂ *branch*Â para a nova linha. EntÃ£o, fazemos oÂ `git rebase main`.

```css
git rebasemainCOPIAR CÃ“DIGO
```

Repare que primeiro, estamos fazendo oÂ *rewind*, ou seja, estamos voltando para o inÃ­cio dessaÂ *branch*. Depois, estamos aplicando oÂ *commit*Â de corrigir a indentaÃ§Ã£o e aplicamos oÂ *commit*Â de quebrando a linha doÂ *script*. Deu tudo certo!

Se passarmosÂ `git log`Â agora, reparem que oÂ *branch*Â `nova-funcionalidade`Â comeÃ§a a partir doÂ *branch*Â `main`, do novoÂ `main`Â que criamos localmente. EntÃ£o, reescrevi a histÃ³ria. Agora, podemos fazer oÂ `git push origin main`.

```css
git push originmainCOPIAR CÃ“DIGO
```

Seguido deÂ `git push origin nova-funcionalidade`.

```perl
gitpush origin nova-funcionalidade
COPIAR CÃ“DIGO
```

Estamos mandando tudo para o repositÃ³rio remoto. Claro, podemos voltar para oÂ `git switch main`Â e fazer umÂ `git merge nova-funcionalidade`.

## Git Merge

O comando **`git merge`** Ã© utilizado para mesclar alteraÃ§Ãµes de diferentes ramos no Git. Quando vocÃª tem dois ramos, como um ramo de desenvolvimento e um ramo de feature, e deseja incorporar as alteraÃ§Ãµes de um ramo para o outro, vocÃª usa o **`git merge`**.

A sintaxe bÃ¡sica do comando Ã©:

```arduino
arduinoCopy code
git merge <nome-do-ramo>

```

Onde **`<nome-do-ramo>`** Ã© o nome do ramo que vocÃª deseja mesclar com o ramo atual.

Por exemplo, se vocÃª estiver no ramo **`main`** e quiser mesclar as alteraÃ§Ãµes do ramo **`feature`**, vocÃª executaria:

```sql
sqlCopy code
git merge feature

```

Isso combinarÃ¡ as alteraÃ§Ãµes do ramo **`feature`** com o ramo **`main`**. Se houver conflitos durante a mesclagem (ou seja, o Git nÃ£o conseguirÃ¡ combinar automaticamente as alteraÃ§Ãµes), vocÃª precisarÃ¡ resolvÃª-los manualmente.

AlÃ©m disso, vocÃª pode encontrar opÃ§Ãµes adicionais para o comando **`git merge`**, como **`--no-ff`**, que forÃ§a uma "mesclagem de commit" mesmo que o Git possa fazer uma "mesclagem rÃ¡pida" (fast-forward), ou **`--squash`**, que mescla todas as alteraÃ§Ãµes em um Ãºnico commit. Estas sÃ£o utilizadas em situaÃ§Ãµes especÃ­ficas, dependendo do fluxo de trabalho e das preferÃªncias da equipe.

Em resumo, **`git merge`** Ã© usado para combinar o histÃ³rico de commits de dois ramos diferentes em um Ãºnico ramo.

Com isso, ele vai conseguir fazer oÂ *fast-forward*Â porque jÃ¡ fiz oÂ `rebase`, entÃ£o nÃ£o precisa daqueleÂ *commit*Â deÂ *merge*. Porque, novamente, ele jÃ¡ reescreveu a histÃ³ria garantindo que os doisÂ *branches*Â nÃ£o sejam mais separados e sim que podem estar juntos.

Reparem que quando fazemos oÂ `merge`, conseguimos fazer oÂ `fast-forward`. EntÃ£o, agora, novamente fazemos oÂ `git push origin main`Â que agora tem aÂ `nova-funcionalidade`.

Um detalhe importante antes de finalizar e queÂ `fast-forward`,Â `commit`Â deÂ `merge`, parecem ser detalhes bem pequenos e, na verdade, sÃ£o. Quando estamos trabalhando, podemos simplesmente executar oÂ `git merge`Â sem saber se ele vai fazer oÂ `fast-forward`Â ou se vai fazer umÂ *commit*Â deÂ `merge`.

PorÃ©m, em algumas empresas, podem ter polÃ­ticas onde todos osÂ `merges`Â precisem ser feitos com oÂ `fast-forward`. EntÃ£o, antes de qualquerÂ `merge`, Ã© preciso fazer umÂ `rebase`.

TambÃ©m pode ser o contrÃ¡rio, precisamos garantir que nunca utilizaremos oÂ `fast-forward`Â para sempre ter no grafo doÂ *log*Â as ramificaÃ§Ãµes. EntÃ£o, podemos utilizar estratÃ©gias para isso tambÃ©m.

Mas, para o nosso cenÃ¡rio, jÃ¡ Ã© o suficiente conhecer os comandosÂ `merge`Â para mesclar trabalhos e o comandoÂ `rebase`Â para reescrever a histÃ³ria e garantir que uma novaÂ *branch*Â possa ser atualizada a partir de umaÂ *branch*Â anterior.

O trabalho doÂ `rebase`Â Ã© equivalente ao que vimos na prÃ¡tica comoÂ *fast forward*Â do merge. Ao realizar oÂ `rebase`, todos os commits da outraÂ *branch*Â sÃ£o adicionadosÂ **antes**Â do primeiro commit da nossaÂ *branch*Â atual, reescrevendo a histÃ³ria. Isso faz com que novas alteraÃ§Ãµes possam ser integradas Ã  nossa branch e permite que quando formos realizar oÂ `merge`, nÃ£o seja necessÃ¡rio umÂ *merge commit*, garantindo oÂ *fast forward*.

## **Nessa aula, nÃ³s:**

- Entendemos o problema queÂ *branches*Â resolvem ao colaborar com uma equipe em um projeto, organizando a colaboraÃ§Ã£o, evitando conflitos e garantindo que uma funcionalidade seja enviada apenas quando estiver pronta;
- Conhecemos os comandosÂ `git branch`Â eÂ `git switch`Â para manipular asÂ *branches*Â existentes;
- Vimos como unir o trabalho de duasÂ *branches*Â com o comandoÂ `git merge`;
- Aprendemos sobre as abordagens deÂ *merge commit*Â eÂ *fast forward*Â doÂ `git merge`;
- Conseguimos reescrever a histÃ³ria de umaÂ *branch*Â utilizando o comandoÂ `git rebase`.

Se vocÃª conhece o git com certeza jÃ¡ usou o comandoÂ **git checkout**. As novas versÃµes do git mexeram nesse comando para deixar ele mais coerente. Na verdade oÂ *git checkout*Â foi separado em dois comandos:

- `git restore`
- `git switch`

---

### **Recuperando as alteraÃ§Ãµes**

Podemos executar o comandoÂ `git stash pop`. EsseÂ *pop*, ele aplica o que tiver na nossa gaveta, no nosso estoque.

ApÃ³s executarmos oÂ `git stash pop`, a funÃ§Ã£o nÃ£o estÃ¡ mais na linha 12. EntÃ£o, podemos continuar a implementaÃ§Ã£o e trazÃª-la para cima. Agora temos o nosso estado finalizado.

> Portanto, oÂ git stashÂ guarda uma alteraÃ§Ã£o para que ela possa ser retomada depois.
> 

Ele guarda um estado para que possamos retomÃ¡-lo depois. E normalmente Ã© utilizado quando estamos no meio de uma alteraÃ§Ã£o, queremos guardar algo rapidamente para corrigir um bug e trabalhar em outra coisa rapidamente e depois voltar a trabalhar nisso. Portanto, nÃ£o podemos criar umÂ *commit*.

Um detalhe: vamos criar esseÂ *stash*Â novamente. Vamos limpar o nosso terminal e rodar oÂ `git stash`. Se executarmos o comandoÂ `git stash list`, ele lista tudo o que estÃ¡ nesse nosso estoque. E repare que temos duas coisas no nossoÂ *stash*, jÃ¡ tÃ­nhamos adicionado algo antes.

```csharp
$ git stash list
stash@{0}: WIPon movendo-detalhes: c53eb16 Quebrando linhado script
stash@{1}: WIPon main: c53eb16 Quebrando linhado script
$
COPIAR CÃ“DIGO
```

Digamos que nÃ£o queremos mais nada naÂ *stash*. Ou entÃ£o, queremos fazer oÂ `git stash pop`Â primeiro para recuperar essa nossa alteraÃ§Ã£o. Feito oÂ `git stash pop`, a nossa alteraÃ§Ã£o voltou a aparecer e estamos com o nosso cÃ³digo no estado correto.

Mas repare que os nomes que esse nossoÂ `git stash list`Â nos mostra nÃ£o sÃ£o muito descritivos. Ele coloca umÂ *work in progress*Â (*WIP*) naÂ *branch*Â que estÃ¡vamos e o ÃºltimoÂ *commit*Â antes de adicionarmos esseÂ *stash*. Portanto, isso nÃ£o Ã© muito Ãºtil.

### **Limpando as alteraÃ§Ãµes guardadas**

Vamos mostrar duas coisas. A primeira Ã© que temos aqui no nossoÂ `git stash list`Â algo anterior que fizemos alguns testes que nÃ£o fazem parte dessa aula. Portanto, como podemos limpar a nossaÂ *stash*, apagar tudo? Podemos fazer umÂ `git stash clear`, limpamos a nossaÂ *stash*. Portanto, se fizermos oÂ `git stash list`, nÃ£o tem mais nada lÃ¡.

### **Acrescentando uma descriÃ§Ã£o Ã Â `stash`**

Agora, se quisermos adicionar algo a nossaÂ *stash*, mas com um nome mais descritivo, podemos fazer, ao invÃ©s de sÃ³Â `git stash`, vamos escreverÂ `git stash push -m`. E aÃ­, podemos adicionar uma mensagem qualquer, serÃ¡Â `"Movendo chamada de funÃ§Ã£o"`.

```perl
git stashpush -m "Movendo chamada de funÃ§Ã£o"
COPIAR CÃ“DIGO
```

Quando voltamos lÃ¡ para o nosso cÃ³digo, a alteraÃ§Ã£o foi desfeita. E se fizermos umÂ `git stash list`, temos um nome bem mais descritivo:Â `Movendo chamada de funÃ§Ã£o`. Agora, sabemos o que isso significa. E podemos adicionar vÃ¡rias coisas naÂ *stash*, como mostramos.

Por exemplo, temos algo na nossaÂ *stash*Â e vamos adicionar algo mais. Como, por exemplo, vamos remover todas essas quebras de linhas no final. Fizemos vÃ¡rias quebra de linha, estamos no meio da implementaÃ§Ã£o, tivemos que parar de novo. Usamos o comandoÂ `git stash`Â novamente.

Fizemos umÂ `git stash`, adicionamos essa modificaÃ§Ã£o lÃ¡ na nossa lista de modificaÃ§Ãµes que queremos rever depois. Se escrevermosÂ `git stash list`, ele listarÃ¡ oÂ `movendo chamada de funÃ§Ã£o`Â e a ÃºltimaÂ `stash`Â que nÃ£o tem um nome especÃ­fico. Portanto, ela aparece comoÂ `WIP on movento-detalhes: c53eb16 Quebrando linha do script`.

### **Entendendo a pilha de modificaÃ§Ãµes**

Se fizermos umÂ `git stash pop`, ele sempre vai aplicar a Ãºltima alteraÃ§Ã£o que adicionamos. Portanto, ele sempre pega esse de Ã­ndice zero. Ele sempre vai empilhando modificaÃ§Ãµes.

O que isso quer dizer? Imagina que essa nossaÂ `stash`Â Ã© uma gaveta e nessa gaveta estamos guardando pratos. Portanto, abrimos a gaveta, colocamos um prato. Na gaveta, adicionamos outro prato em cima. Se vamos pegar um prato, pegamos o prato que estÃ¡ em cima, certo? Portanto, Ã© o Ãºltimo que adicionamos. Isso Ã© oÂ **conceito de pilha**.

Temos aqui naÂ *stash*Â umaÂ **pilha de modificaÃ§Ãµes**. Portanto, quando fazemosÂ *pop*, sempre aplicamos a Ãºltima que adicionamos. Fizemos umÂ `git stash pop`, temos a remoÃ§Ã£o das quebras de linha.

Portanto, se fizermos nossoÂ `git stash list`Â de novo, sÃ³ temos um e agora o nosso Ã­ndice zero Ã© aquelaÂ `movendo chamada da funÃ§Ã£o`. SÃ³ que, imagina o seguinte cenÃ¡rio: Removemos todas as quebras de linha e vamos fazer oÂ `git stash`Â de novo.

### **Retomando alteraÃ§Ãµes anteriores Ã  versÃ£o mais recente**

No nossoÂ `git stash list`, temos lÃ¡ aÂ `movendo chamada da funÃ§Ã£o`, que agora Ã© o Ã­ndice 1. E o novo Ã­ndice zero Ã© essa remoÃ§Ã£o de quebras de linha lÃ¡ do final. SÃ³ que o que queremos voltar a trabalhar no que estÃ¡ guardado nesse Ã­ndice 1.

```kotlin
$ git stash list
stash@{0}: WIP on movendo-detalhes: c53eb16 Quebrando linhado script
stash@{1}: On movendo-detalhes: Movendo chamada defunÃ§Ã£o
$
COPIAR CÃ“DIGO
```

Portanto, se fizermos oÂ `git stash pop`, nÃ£o vai funcionar. Vamos pegar a Ãºltima alteraÃ§Ã£o que nÃ£o Ã© o que queremos. Portanto, nesses cenÃ¡rios, quando queremos aplicar algo que estÃ¡ naÂ `stash`Â anterior Ã  versÃ£o mais recente, podemos fazer oÂ `git stash apply`Â e o Ã­ndice, no nosso caso, o Ã­ndice 1, que Ã© oÂ `movendo chamada da funÃ§Ã£o`.

Antes de executar, temos todas as quebras de linha no final do arquivo e a chamada da funÃ§Ã£o estÃ¡ na linha 17. Vamos executar agora no nosso terminal,Â `git stash apply 1`. O que vai acontecer? Temos a nossa funÃ§Ã£o sendo movida, mas todas as quebras de linha continuam lÃ¡ no final.

Se quisermos, podemos aplicar mais de um item deÂ `stash`. Portanto, podemos fazer aqui o nossoÂ `git stash pop`Â sem problema. SÃ³ que aÃ­ vamos ter um conflito.

> Podemos aplicar vÃ¡riasÂ stashesÂ se elas nÃ£o estiverem no mesmo arquivo, se elas nÃ£o forem conflitar com o que temos.
> 

Temos modificaÃ§Ãµes no arquivo que seriam sobrescritas. Portanto, nÃ£o vamos aplicar essaÂ `stash`Â mais. Portanto, se fizermos umÂ `stash list`, ele adicionou um novo detalhe lÃ¡ na nossaÂ `stash`.

Para recapitular, se temos alguma alteraÃ§Ã£o que precisamos adicionar ou salvar para depois, chamamos o comandoÂ `git stash`. O comandoÂ `git stash`Â vai adicionando mensagens no formato de pilha.

Recapitulando:

- Se queremos pegar algo e aplicar uma alteraÃ§Ã£o Ã  ÃºltimaÂ `stash`Â que adicionamos, usamosÂ `git stash pop`;
- Se queremos aplicar alguma especÃ­fica, usamosÂ `git stash apply`;
- Se queremos adicionar algo na nossaÂ `stash`Â com mensagem, usamosÂ `git stash push`;
- Se queremos limpar a nossaÂ `stash`, usamosÂ `git stash clear`.

Vamos desfazer a alteraÃ§Ã£o de mover. NÃ£o queremos mover essa mensagem, queremos fazÃª-la voltar para onde ela estava originalmente. Portanto, agora temos o nosso cÃ³digo no estado original, certo?

No entanto, se fizermos umÂ `git status`, temos uma alteraÃ§Ã£o ainda. Se fizermos umÂ `git diff`, repare que essa alteraÃ§Ã£o Ã© invisÃ­vel para nÃ³s.

Portanto, provavelmente, o nosso Visual Studio Code apagou alguns espaÃ§os que estavam em uma linha. SÃ³ que nÃ£o queremos comitar isso, queremos desfazer essa alteraÃ§Ã£o. Como podemos desfazer alteraÃ§Ãµes que estÃ£o prontas para serem adicionadas a umÂ *commit*? AtravÃ©s doÂ `git`. Ã‰ isso que vamos fazer no prÃ³ximo vÃ­deo.

Os comandosÂ `pop`,Â `drop`Â eÂ `apply`Â doÂ `git stash`Â possuem semelhanÃ§as e diferenÃ§as bem importantes, entÃ£o vamos fazer um pequeno resumo de suas funcionalidades aqui:

### **Apply**

O comandoÂ `git stash apply`Â espera um Ã­ndice de um item naÂ *stash*Â e o aplica ao repositÃ³rio, porÃ©m, esse comandoÂ **nÃ£o remove**Â o item daÂ *stash*, ou seja, se apÃ³s executar o comandoÂ `git stash apply 1`Â vocÃª executarÂ `git stash list`, o item referente ao Ã­ndice 1 continuarÃ¡ naÂ *stash*.

### **Pop**

OÂ `git stash pop`Â faz exatamente a mesma coisa que oÂ `git stash apply`, porÃ©m, alÃ©m de aplicar o item daÂ *stash*, ele tambÃ©m o remove de lÃ¡. Esse comando, sem nenhum parÃ¢metro extra, vai aplicar o Ãºltimo item adicionado Ã Â *stash*, mas nÃ³s tambÃ©m podemos informar um Ã­ndice para ele, comoÂ `git stash pop 1`.

### **Drop**

OÂ `git stash drop`Â funciona exatamente como oÂ `pop`, mas com uma simples diferenÃ§a: ele apenas remove o item daÂ *stash*, sem aplicÃ¡-lo em nosso repositÃ³rio. Dessa forma,Â `git stash drop`Â remove o Ãºltimo item adicionado Ã Â *stash*, enquanto oÂ `git stash drop 1`Â remove daÂ *stash*Â o item com Ã­ndice 1.

---

o comandoÂ `git restore`Â pode restaurar estados de um arquivo ou de um projeto inteiro. Dissemos que querÃ­amos "viajar no tempo", mas antes precisamos mostrar um detalhe interessante.