# GITHUB - Comandos

[GitHub - thayanecperes/comandos-teste: Testando comandos GIT](https://github.com/thayanecperes/comandos-teste/tree/main)

[Git e Github para Sobrevivência | Alura Cursos Online](https://www.alura.com.br/webseries/git-e-github-para-sobrevivencia/)

Para que possamos realizar o controle de versão de um projeto, registrando as mudanças realizadas nele ao longo do tempo, devemos, primeiramente, transformar o diretório do projeto em um repositório Git. 

## Git init:

O comando `git init` é utilizado para esse objetivo, devendo ser executado apenas **uma vez**. Quando executado, ele configura o diretório atual para ser rastreado pelo Git, inicializando um repositório vazio.

### **Cuidados com o comando git init**

Aprendemos que o comando `git init` serve para criar um novo repositório Git e por isso deve ser executado apenas uma única vez. Ou seja, se um diretório já for um repositório Git, não faz sentido rodar novamente o comando `git init`. Esse é um erro bastante comum de ser cometido.

---

## Git add:

Git add é usado para adicionar as alterações dos arquivos do repositório no Git para em seguida ser realizado o commit. 

```sql
git add nome-do-arquivo.txt
```

Para facilitar esse processo, temos um atalho no comando do Git, onde podemos **adicionar todos os arquivos de uma só vez**. É o comando `git add .`. Esse ponto vai adicionar todos os arquivos do repositório. 

---

## Git commit:

O próximo comando que encontramos é o `git commit -m` e temos que inserir uma mensagem entre aspas. Copiamos até o `-m`, porque vamos alterar a mensagem. Colocaremos a mensagem `projeto inicial` entre aspas duplas.

```sql
gitcommit -m "projeto inicial"
```

Apesar de não existir uma regra universal para a escrita das mensagens de commit, algumas boas práticas podem ser seguidas para garantir que outras pessoas, e até mesmo você no futuro, entendam que alterações foram feitas e por quê.

As mensagens dos commits devem ser **simples e objetivas**. A seguir, listamos algumas orientações para isso:

- **Mantenha a mensagem curta e concisa:** A primeira linha da mensagem deve conter, no máximo, 72 caracteres. Caso seja necessário uma descrição adicional, você deve pular uma linha e adicionar os detalhes, como o contexto, da mudança realizada.
- **Uso de verbo no infinitivo:** É comum que a mensagem do commit inicie com um verbo no infinitivo que descreva a alteração feita, como “adicionar”, “corrigir” ou “atualizar”. Em sequência, são adicionados detalhes concisos da mudança. Por exemplo: “Atualizar texto do título da página”.
- **Evite detalhes técnicos**: Não inclua detalhes técnicos complexos na mensagem de commit. Esses detalhes podem ser adicionados nos comentários de código ou na documentação.

É importante ter em mente que a mensagem do commit é uma forma de documentação do histórico das mudanças que ocorreram ao longo do código. A pessoa que ler essa mensagem pode não ter conhecimento do contexto original. Assim, garanta que suas mensagens de commit tenham clareza e sejam suficientemente descritivas.

Um commit deve ser realizado sempre que você **finalizar uma tarefa** específica ou **resolver algum bug**. Isso mantém o histórico de commits claro e rastreável, de modo que seja possível entender o que foi feito em cada commit.

Assim, é importante realizar commits frequentemente. Porém, evite realizar commits muito pequenos ou muito grandes, pois isso pode tornar difícil o seu entendimento.

Lembre-se de **nunca realizar um commit de um código que você sabe que contém bugs**. O ideal é que o commit contenha somente código funcional.

O controle de mudanças do Git é feito através dos **commits**. Cada commit armazena o **estado completo** do projeto em um determinado momento por meio de um **snapshot**. Ou seja, cada commit é um registro completo do repositório no momento em que esse commit foi criado.

Cada commit possui por padrão um autor, que é a pessoa que realizou aquelas alterações no código.

Entretanto, quando trabalhamos em equipe pode ser que algum trecho de código seja escrito em dupla ou trio. Assim, como definir a autoria dessas outras pessoas no commit?

O Git oferece a possibilidade de adicionar **mais de um autor** a um commit. Para isso, após escrever a mensagem do commit, pulamos duas linhas e usamos a palavra-chave `Co-authored-by:`, seguido do nome e e-mail associado ao GitHub (entre < >) de cada pessoa colaboradora.

Cada coautor deve estar em uma linha diferente, como é mostrado no exemplo a seguir:

```perl
$ git commit -m "Adicionar nova funcionalidade.
>
>
Co-authored-by: NOME <nome@email.com>
Co-authored-by: OUTRO-NOME <outro@email.com>"
COPIAR CÓDIGO
```

Caso queira entender mais sobre coautoria no GitHub, você pode acessar a [documentação referente ao assunto](https://docs.github.com/pt/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/creating-a-commit-with-multiple-authors).

---

## Git remote:

Usado para unificar bifurcações entre os repositórios 

1. **`git remote add <name> <url>`** é um comando no Git usado para adicionar um novo repositório remoto à sua configuração local do Git. Aqui está uma explicação detalhada:
    1. **`git remote`**: Este é o comando utilizado para lidar com repositórios remotos no Git.
    2. **`add`**: Indica que você está adicionando um novo repositório remoto à sua configuração local.
    3. **`<name>`**: É o nome que você deseja atribuir a esse repositório remoto. Geralmente, isso é algo descritivo, como "origin", que é um nome comum para se referir ao repositório de onde você clonou o projeto.
    4. **`<url>`**: É o URL do repositório remoto que você está adicionando. Isso pode ser um URL HTTPS ou SSH para o repositório remoto no qual você deseja enviar suas alterações.
    
    Por exemplo, se você quisesse adicionar um repositório remoto chamado "origin" com o URL "https://github.com/seu-usuario/seu-projeto.git", você usaria o seguinte comando:
    
    ```csharp
    
    git remote add origin https://github.com/thayanecperes/git-github
    
    ```
    
    Depois de executar este comando, o Git reconhecerá o repositório remoto com o nome "origin" e você poderá enviar suas alterações para ele usando comandos como **`git push origin <branch>`**.
    

```csharp
git remoteadd apelido url
COPIAR CÓDIGO

```

'apelido': Este é um nome que você atribui ao repositório remoto. Geralmente, se utiliza nomes descritivos, como "origin" para o repositório principal no GitHub, mas você pode escolher nomes que façam sentido para o seu projeto.

2 -  `git remote -v`Listar os repositórios remotos:

Para listar os repositórios remotos associados ao seu projeto local, você pode utilizar o comando `git remote -v`. Isso exibirá uma lista de todos os repositórios remotos vinculados ao seu projeto, juntamente com suas URLs. Veja um exemplo:

```
git remote -v
COPIAR CÓDIGO
```

A saída será algo semelhante a:

```perl
origin   https://github.com/seu-usuario/seu-projeto.git (fetch)
origin   https://github.com/seu-usuario/seu-projeto.git (push)
COPIAR CÓDIGO
```

Essa lista é útil para verificar se os repositórios remotos estão configurados corretamente. Obs: Vai aparecer duplicado mesmo, pois o Git separa a url de envio de commits (push) da url de baixar commits (fetch).

3 - Remover um repositório remoto:

Caso você não precise mais de um repositório remoto específico, pode removê-lo com o comando `git remote remove apelido`. Substitua 'apelido' pelo nome do repositório remoto que deseja remover. Aqui está um exemplo:

```csharp
git remote remove origin
COPIAR CÓDIGO
```

Após a execução deste comando, o repositório remoto chamado "origin" será desvinculado do seu projeto local.

4 - Alterar a URL de um repositório remoto:

Às vezes, é necessário atualizar a URL de um repositório remoto, como quando a URL do servidor do GitHub é modificada ou quando você copiou a URL incorreta ao adicionar o repositório remoto. Use o comando `git remote set-url apelido nova_url` para realizar essa atualização. Substitua 'apelido' pelo nome do repositório remoto e 'nova_url' pela nova URL que você deseja associar a ele. Aqui está um exemplo:

```cpp
git remote set-url origin https://github.com/seu-usuario/seu-repositorio.git
COPIAR CÓDIGO
```

Isso atualizará a URL do repositório remoto "origin" para a nova URL especificada.

5 - Alterar o apelido de um repositório remoto:

Se você deseja renomear um repositório remoto, use o comando `git remote rename apelido novo_apelido`. Substitua 'apelido' pelo nome atual do repositório remoto e 'novo_apelido' pelo novo nome que você deseja atribuir a ele. Aqui está um exemplo:

```lua
git remote rename origin novo-origin
COPIAR CÓDIGO
```

Isso renomeará o repositório remoto de "origin" para "novo-origin".

Lembre-se de que o comando git remote é fundamental para a gestão de conexões entre seu repositório local e repositórios remotos, permitindo a colaboração eficiente e o controle de versão. Praticar esses comandos em seu ambiente de desenvolvimento ajudará a consolidar seu entendimento.

---

## Git push

O comando `git push` deve ser executado para **sincrnizar** as mudanças do repositório local com o repositório remoto, ou seja, quando desejamos enviar os novos commits que realizamos em nosso repositório local para o repositório remoto. No entanto, para garantir uma conexão segura, é essencial configurar uma **chave SSH** no computador antes de executar esse comando.

---

## Git pull

O comando `git pull` tem como objetivo, baixar os novos commits que outras pessoas colaboradoras do seu repositório enviaram para o GitHub. Com isso, temos um fluxo de trabalho.

Ele funciona como o oposto do `push`, já que puxa os commits do remoto para o local.

Para isso, além de `git pull`, na mesma linha de código indicamos qual é o repositório remoto do qual baixaremos esses commits, nesse caso será o `origin`. Em seguida, passamos a *branch* `main`, onde ele trará esses commits para o repositório local.

```css
git pull originmainCOPIAR CÓDIGO
```

---

## **Clonando um repositório**

git clone + url do repositorio a ser clonado.
esse comando faz o donwload do repositorio. 

```lua
git status

```

O GitHub tem essa sinalização pelas cores, se os arquivos modificados, mas não foram adicionados ficam vermelhos quando são ficam verdes.

**`git clone`** é um comando utilizado para criar uma cópia local (clone) de um repositório Git remoto. Isso permite que você obtenha uma cópia completa de todos os arquivos e histórico de commits do repositório remoto em seu próprio computador.

A sintaxe básica do comando **`git clone`** é a seguinte:

```php
phpCopy code
git clone <url_do_repositório_remoto> [<diretório_de_destino>]

```

- **`<url_do_repositório_remoto>`** é o URL do repositório remoto que você deseja clonar.
- **`[<diretório_de_destino>]`** é o diretório onde o repositório será clonado. Se não for especificado, o Git criará um diretório com o mesmo nome do repositório remoto.

Por exemplo, se você quiser clonar um repositório chamado "meu-projeto" do GitHub para um diretório chamado "meu-projeto-local", você usaria o seguinte comando:

```bash
bashCopy code
git clone https://github.com/usuario/meu-projeto.git meu-projeto-local

```

Após a execução deste comando, o Git criará uma cópia completa do repositório "meu-projeto" e seu histórico de commits dentro do diretório "meu-projeto-local" em seu computador.

---

## Git log

Para verificarmos se isso foi feito, podemo rodar o `git log`.

```bash
`git log`
```

Quando estivermos trabalhando em um projeto e precisarmos realizar mudanças, usaremos o `git status` para verificar os arquivos modificados.

Adicionaremos essas mudanças com o comando `git add`, depois, realizaremos um commit com o `git commit`. Subiremos essas mudanças para o repositório com o `git push` e eventualmente, conforme outras pessoas forem colaborando com o projeto, traremos essas mudanças novamente para o computador com o `git pull`.

### **Alterando a visualização do log**

Imagine que desejamos apenas **visualizar as mensagens dos *commits***, de forma simplificada. Não estamos interessados em quem foi o autor do `commit`, em qual *branch* ele está, ou outros detalhes. Não desejamos verificar o *hash* completo do `commit`, apenas uma lista das mensagens, de forma mais compacta, linha por linha.

Para sair do comando `git log`, pressionaremos "Q". Agora, no terminal, digitaremos `git log`, mas com a *flag* `--oneline`.

```lua
git log --oneline
```

Isso nos permitirá visualizar o *log* de *commits* de forma muito mais resumida.

Com `git log --oneline`, teremos nosso histórico de *commits* exibido com os *hashes* reduzidos, mostrando apenas os primeiros caracteres do *hash*. Isso já é suficiente para identificarmos algum *commit*.

No entanto, o oposto pode ocorrer. Estamos interessados em examinar o commit e suas alterações, não apenas sua mensagem, mas também seu conteúdo. Portanto, ao retornar ao terminal, limpamos a tela e digitamos o comando `git log -p`.

```bash
git log -p
```

Essa opção `-p` vai nos fornecer, além das informações padrão, o hash completo, o autor ou autora, a data e a mensagem do *commit*.

Além disso, ele mostrará um `diff`, que é essencialmente um formato que o *git* utiliza para exibir as **alterações** de um *commit* específico.

Vamos entender o formato dessas alterações. Primeiramente, descemos, pressionando a tecla de seta para baixo, até a seção referente ao `index.html`, nosso arquivo principal, onde a maioria das alterações está ocorrendo.

Aqui, ele mostra como esse formato funciona. Ele diz que as linhas que começam com "`-`" (`---- a/index.html`), significa que foram linhas que foram **removidas**. E as linhas que começam com "+" (`+++ b/index.html`), são as linhas **adicionadas**.

Então, se houver alguma modificação, uma mudança em uma linha, veremos duas entradas nesse `diff`: uma em que a linha começa com "-" e outra em que a linha começa com "+", indicando que trocamos uma linha por outra.

Ao analisar a saída no terminal, fechamos esse menu com os arquivos para visualizar essa saída um pouco melhor. Observamos que a linha com o `h1` foi alterada; portanto, foi mudado de "Adivinhe" para "Descubra". **Esse é o formato diff**.

### **Outras formas de exibição do *log***

E várias outras opções também, como o `git log --graph`, que exibirá uma linha do nosso *log*, e isso será ainda mais útil quando falarmos um pouco sobre *branches*.

Mas, essencialmente, se percorro isso até a parte em que temos um `merge`, que foi feito no curso anterior, percebemos que ele representa graficamente uma linha do tempo se desviando para outro ponto e depois retornando à nossa linha principal.

Note que à esquerda há uma linha vertical, e a partir do ponto de `merge`, outra linha se ramifica dessa vertical, estendendo-se até o `commit` do Rodrigo. Isso ficará um pouco mais claro, mas com o uso de `--graph`, conseguimos visualizar o *log* de uma forma mais **visual**.

Há ainda uma opção interessante, que é o `--pretty` ou `--format`. Ambos são sinônimos.

```lua
git log --pretty
git log --format
COPIAR CÓDIGO
```

Com `--format` ou `--pretty`, podemos exibir o *commit* da maneira que desejar. Por exemplo, utilizarmos `--format=""` e dentro das aspas digitar `%H %an`.

```perl
gitlog --format="%H %an"
COPIAR CÓDIG
```

### **Usando o `git log --help`**

E como sabemos quais são as opções, de onde vem esse `%H`, `%an`? Se digitamos `git log --help`, temos um manual, uma ajuda desse comando. E se digitarmos `/pretty formats` e teclarmos "Enter".

```
/PRETTY FORMATS
COPIAR CÓDIGO
```

Em "*PRETTY FORMATS*", visualizamos que conseguimos escolher diversos formatos. Temos o formato de *one line*, *short*, *medium*, *full*, *fuller*, e aqui conseguimos colocar coisas específicas, um formato específico.

> Exemplo de formato:
> 

```xml
short
commit <hash>
Author: <author>

<title line>
COPIAR CÓDIGO
```

Os *placeholders* para nova linha, ou então, por exemplo, mudar a cor para deixar esse *log* mais legível, bem formatado. Mas temos o *hash* do `commit` com `%H` maiúsculo, ou o *hash* abreviado com `%h` minúsculo.

Também temos o nome da autora ou do autor, que é o `%an`, ou o nome do autor com `%aN` maiúsculo, o email com `%ae`, a data do `commit`, então `%aD`, temos diversas informações que podemos utilizar aqui.

Portanto, se descermos nesta página de documentação, veremos que esse `pretty` ou `format` pode ser utilizado de forma bem ampla. Isso normalmente é usado quando estamos criando algum *script*, automatizando alguma coisa. Então, no dia a dia, não vamos utilizar tanto.

Agora, o `git log --oneline` e o `git log -p`, esses sim são comandos bastante utilizados no dia a dia.

---

### **Git show:**

**Analisando um `commit` específico**

Desejamos compreender as alterações realizadas neste *commit* específico, independentemente de quem o tenha feito. Portanto, ao pressionarmos "Q", sairemos do registro (*log*) e solicitaremos ao *Git* que nos apresente o conteúdo e os detalhes desse *commit*.

Para isso, copiaremos o *hash* correspondente e digitaremos `git show`, seguido do respectivo *hash*.

> git show {hash do commit}
> 

```sql
gitshow 2ad48c0
COPIAR CÓDIGO
```

O comando `git show` nos proporcionará uma exibição semelhante ao `git log -p`, porém focado apenas no *commit* em questão, não em todo o registro:

Observe como o comando `git show` é bastante simples, ele exibe o *diff* para nós. Novamente, basta pressionar "Q" para sair. Um detalhe interessante é que, ao digitarmos `git show --help`, podemos entender melhor como o comando funciona.

---

### **Git diff**

O comando **`git diff`** é usado para exibir as diferenças entre os arquivos no diretório de trabalho e o índice (staging area), ou entre o índice e o último commit, ou entre duas confirmações.

A sintaxe básica é:

```css
cssCopy code
git diff [<arquivo>]

```

Se nenhum arquivo for especificado, o comando mostrará as diferenças entre o diretório de trabalho e o índice. Se um arquivo for especificado, ele mostrará as diferenças desse arquivo entre o diretório de trabalho e o índice.

Alguns exemplos de uso comuns:

- **Diferenças entre o diretório de trabalho e o índice:**
    
    ```
    
    git diff
    
    ```
    
- **Diferenças entre o índice e o último commit:**
    
    ```
    shCopy code
    git diff --cached
    
    ```
    
- **Diferenças entre o diretório de trabalho e o último commit:**
    
    ```
    shCopy code
    git diff HEAD
    
    ```
    
- **Diferenças em um arquivo específico:**
    
    ```
    shCopy code
    git diff nome_do_arquivo
    
    ```
    

O **`git diff`** mostra as diferenças de linha a linha entre os arquivos. As linhas marcadas com **`-`** indicam linhas removidas e as linhas marcadas com **`+`** indicam linhas adicionadas.

Se você estiver revisando as mudanças antes de fazer um commit, **`git diff`** pode ser muito útil para ver exatamente o que foi alterado nos seus arquivos.

## **Conclusão**

Agora, uma observação interessante: se estivermos no meio de uma edição, realizando alterações, mas ainda não fizemos o registro de alterações? E queremos visualizar o que já foi alterado, o que está pronto para ser registrado.

Como podemos fazer isso? Como podemos ver as diferenças (diff) dos arquivos que ainda não foram incluídos no registro de alterações (commit)?

Para analisar a diferença entre esses dois *commits* específicos, precisamos incluir os três *commits* em nossa análise. Podemos fazer isso utilizando o comando `git diff`.

Primeiro, copiamos o *hash* do *commit* mais antigo que desejamos comparar, que é o "deixando o jogo mais fácil", e depois colamos esse *hash* seguido de "`..`": `git diff 5880fc1..`. Em seguida, copiamos o *hash* do *commit* mais recente que queremos comparar, que é o "deixando o jogo mais fácil ainda", e o colamos após "..".

Agora é hora de compreender o significado de *branch*, assim como o que representa essa referência à `main` quando executamos `git status`. Portanto, primeiro realizaremos um `git push origin main` e, em seguida, no próximo vídeo, nos aprofundaremos no entendimento do conceito de *branch*.

1 - Para começar a explorar os comandos que exibem a visualização de alterações no projeto, utilize o comando `git log` com os seguintes parâmetros:

- a) `p` para visualizar as alterações em cada arquivo modificado;
- b) `-oneline` para visualizar cada commit de forma resumida em uma única linha;
- c) `-graph` para visualizar a linha do tempo dos commits com suas ramificações;
- d) `-pretty` ou `-format` para especificar com detalhes o que será exibido.

2 - Na sequência, execute `git show` para visualizar o trabalho realizado em algum commit específico. Lembre-se que se não for informado algum commit, o último commit será exibido.

3 - Por fim, com `git diff`, exiba a diferença entre 2 pontos da linha do tempo de nosso repositório. Caso nenhum parâmetro seja passado para o comando, a diferença exibida será entre o último commit e o que ainda não foi adicionado com `git add`.

- Aprendemos sobre parâmetros adicionais do `git log` para alterar sua forma de exibição;
- Conhecemos o comando `git show`, que nos exibe os detalhes de um commit específico;
- Utilizamos o comando `git diff` para visualizar as diferenças entre dois pontos no histórico de nosso repositório git.

entendemos como trabalhar mais com *log*, visualizar os detalhes de *commit* com `show`, e as diferenças entre dois estados com `diff`. Agora falaremos sobre **colaboração** e como organizamos o trabalho colaborativo.

---

## Git e a IDE VSCode

Quando estamos trabalhando em um projeto utilizando o versionamento Git e a IDE VSCode, ao adicionar ou alterar algum arquivo aparece uma sinalização ao lado do nome desses arquivos no VSCode, como podemos ver na imagem abaixo:

!https://cdn1.gnarususercontent.com.br/1/1221554/5afdb0f3-f5cc-46b3-88f6-0062f51cbc0c.png

Mas o que isso significa?

- **M**: A letra M representa o estado *Modified*, do português modificado. Isso significa que o arquivo já existia no repositório, mas que recebeu alguma modificação que ainda não foi registrada no Git.
- **U**: A letra U representa o estado *Untracked*, do português não rastreado. Isso significa que o arquivo ainda não existia no repositório e que ainda não teve seu registro (commit) feito no Git.

Essa sinalização nos ajuda a entender o estado atual dos nossos arquivos do projeto no versionamento Git.

---

---

---

# [Git e GitHub: compartilhando e colaborando em projetos](https://cursos.alura.com.br/course/git-github-compartilhando-colaborando-projetos)

## **Problemas ao colaborar**

Queremos levantar um ponto para você: se realizamos, por exemplo, um `push` que gerou erro na aula anterior, é porque utilizamos o usuário de trabalho e não o usuário pessoal. Com o usuário correto selecionado, fizemos o `push` novamente.

```
git push origin main
```

Agora vamos executar o comando abaixo:

```
git log --graph
```

Comentamos que existe uma linha, e em alguns momentos, pode existir uma **bifurcação** nessa linha. Vamos entender o que é essa bifurcação?

### **Simulando um cenário**

Imagine um cenário mais próximo da realidade, onde trabalhamos em um projeto real, grande, com vários arquivos, funcionalidades e uma equipe com diversas pessoas, e nesse trabalho, alteramos alguns arquivos. Para simular esse caso, vamos abrir outro terminal e fazer o `git clone` do projeto:

```
git clone git@github.com:CViniciusSDias/numero-secreto.git
```

Em seguida, vamos acessar o projeto `numero-secreto` em outro lugar:

```
cd numero-secreto/
COPIAR CÓDIGO
```

Ou seja, estamos fora do *Visual Studio Code*, em um terminal em outro local, e vamos abrir o arquivo `index.html` no ambiente diferente de outro editor para modificá-lo.

```
vim index.html
COPIAR CÓDIGO
```

Feito isso, vamos remover o "em" do título "Jogo em JS"; será somente "Jogo JS".

> index.html:
> 

```html
<title>Jogo JS</title>
COPIAR CÓDIGO
```

Uma vez salvo o arquivo, podemos executar o comando `git status`. Além disso, com o comando `git diff`, conseguimos visualizar o que foi alterado.

```
git status
```

```
git diff

```

Agora vamos adicionar o arquivo `index.html`, e na sequência, adicionaremos um `commit` chamado "Removendo palavra do título". Após o `commit`, faremos o `push` para a `origin main`.

```
git add index.html
```

```
git commit -m "Removendo palavra do título"
```

```
git push origin main
```

Imagine que isso foi feito por uma pessoa que trabalha conosco, ou seja, outra pessoa fez o `commit`, o `push`, e está agora no repositório. Nós, ao mesmo tempo, trabalhamos em outra funcionalidade, como, por exemplo, corrigir o acento da palavra "número" na tag `<h1>` da linha 22.

> index.html:
> 

```html
<h1>Descubra o <span class="container__texto-azul">número secreto</span></h1>
```

Após fazer a alteração, vamos abrir o terminal no Visual Studio Code, executar o comando `git diff` para garantir que está tudo certo e que vamos comitar corretamente. Novamente, vamos adicionar o `index.html`, e adicionar o `commit` com a mensagem "Adicionando acento".

```
git commit -m "Adicionando acento"
```

Fizemos o `commit`, mas agora, quando formos fazer o `git push origin main`, o Git vai rejeitar esse `push`, dizendo que existem atualizações feitas que ainda não estão no código.

Isso é um "problema" que já conhecemos antes, então o que precisa ser feito? Primeiro, precisamos fazer um `git pull`. Com isso, ele vai trazer as alterações e fazer o que ele chama de ***merge***.

> Entenderemos melhor sobre merge em breve.
> 

```
git pull
```

Vamos aceitar esse merge. No nosso editor, basta executar o comando `:x` para salvar. Assim, fizemos o merge e agora podemos fazer o `push` do `origin main`, ou seja, ele **buscou as alterações** que estavam no repositório, **mesclou** com as nossas (significado de "merge"), e agora temos o **repositório atualizado**. Com o repositório atualizado, podemos enviar as alterações.

Porém, já abordamos tudo isso no curso anterior e você já passou por esse problema. Tanto que, se fizermos `git log --graph`, temos exatamente o cenário de bifurcação que já vimos anteriormente.

```
git log --graph
```

Por que mostramos isso de novo? Porque, novamente, pensando em um cenário colaborativo, imagine uma equipe pequena, com 10 pessoas. Imagine um projeto pequeno, com 1.000 arquivos.

Isso, em uma escala de mundo real, são coisas pequenas; uma equipe de 10 pessoas é pequena, da mesma forma que um projeto com 1.000 arquivos é pequeno. Imagine ter que lidar com essa situação toda vez que alteramos algum desses 1.000 arquivos para cada uma dessas 10 pessoas.

Toda hora terá alguém enviando modificação para o repositório, porque a cada alteração que fazemos no projeto, executamos um `commit` e enviamos essa alteração, para garantir que, caso nosso computador dê problema, nada seja perdido.

Há ainda outro ponto: imagine que estamos fazendo uma alteração e estamos no processo de tornar a nossa aplicação como um todo **gramaticalmente correta**, então adicionamos o acento em "número", temos que verificar outros arquivos que provavelmente têm a palavra "número" sem acento, e assim por diante.

Com isso, podemos ter vários commits nessa funcionalidade, isto é, uma única funcionalidade pode conter vários commits.

Imagine que corrigimos a palavra "número" e fizemos o `push` para enviar a alteração para o repositório remoto. Assim, todas as pessoas que utilizarem esse repositório, irão visualizar a alteração no meio do caminho. Ainda não terminamos a funcionalidade, mas ela já está no repositório remoto para todos verem.

Imagine que queremos colocar isso em produção. Sempre que vamos colocar um código em produção e disponibilizar efetivamente esse projeto para o mundo ver, ele deve estar pronto, no estado completo.

Portanto, se estamos no meio de uma alteração, não podemos fazer o ***deploy*** (implantação), não podemos colocar esse projeto no ar.

Sendo assim, alguém que desenvolvia outra funcionalidade, agora precisará nos esperar terminar essa funcionalidade para colocar a dela no ar, porque também enviamos metade de uma alteração.

https://git-school.github.io/visualizing-git/

---

## **Git Branch**

**Ramificando o trabalho**

Temos nosso projeto desenvolvido e queremos começar a trabalhar em outra funcionalidade. Para isso, podemos criar uma **ramificação**, um galho na nossa árvore. Isso é o que chamamos de ***branch***.

Se digitarmos o comando `git branch` no Visualizing Git, ele vai mostrar quais são as branches, isto é, quais são as ramificações existentes no nosso trabalho.

```
git branch
COPIAR CÓDIGO
```

Por padrão, só temos a branch `main`, que o Visualizing Git chama de `master`. Antigamente, a branch principal se chamava `master`, mas essa nomenclatura padrão foi alterada para `main`. Sendo assim, hoje em dia, a branch padrão se chama `main`.

Se quisermos **renomear** a `master` para `main`, usamos o comando abaixo:

```
git branch -m master main
COPIAR CÓDIGO
```

Se quisermos **remover** alguma branch, caso tenhamos uma lista de várias branches, podemos usar o comando `git branch -d` seguido do nome da branch que queremos remover. Por exemplo:

```
git branch -d master
COPIAR CÓDIGO
```

### **Criando uma nova ramificação**

Em vez de renomear ou remover, queremos **criar uma nova ramificação**, ou seja, uma nova linha de trabalho, para que possamos criar essa nossa nova funcionalidade.

Vamos chamar essa nova linha de trabalho de `gramatica`. Para isso, basta digitar o comando `git branch` seguido do nome do ramo que queremos trabalhar. Esse ramo, ou seja, essa branch será criada sem espaço, maiúsculas e acentos, porque é uma identificação de algo.

```
git branch gramatica

```

Agora, se fizermos um novo `commit`, ele será feito na branch `master`, onde estamos no momento, ou na branch `gramatica`? Vamos fazer esse `commit` com a mensagem "Onde estou".

```
git commit -m "Onde estou"

```

Perceba que foi feito o `commit` na branch `master`. Não fizemos na branch `gramatica`, porque o local de trabalho do projeto está na branch `master`. Se quisermos modificar a branch atual para outra, precisamos de algum comando, e existem alguns para isso.

---

### **Git checkout**

**Alternando entre *branches***

Primeiro, vamos mostrar um comando antigo, depois falamos sobre o mais novo. Inicialmente, digitaremos um comando chamado `git checkout`. O comando `git checkout` faz um monte de coisa. Nesse caso, se passarmos o nome de uma branch, ele vai alterar onde estamos.

```
git checkout gramatica

```

Ao fazer isso, repare que o `HEAD` muda de lugar e vai para baixo da branch `gramatica`. Isso indica que agora estamos na branch `gramatica`, trabalhando a partir desse commit.

Sendo assim, se fizermos um `commit` com a mensagem "Agora na branch certa", por exemplo, visualizaremos uma ramificação no nosso trabalho.

```
git commit -m "Agora na branch certa"
```

Agora, há duas linhas de trabalho diferentes e **independentes**. Portanto, podemos executar o comando `branch -d master` para remover a branch `master` se quisermos.

```
git branch -d master
```

Feito isso, a branch `master` não existirá mais. Podemos fazer o `git checkout` para a branch `main` e adicionar alguns commits com o comando `git commit` sem mensagem.

```
git checkout main
```

```
git commit
```

Repare que temos, novamente, duas linhas de trabalho diferentes. É isso que o comando `git log --graph` mostrou para nós anteriormente: a **ramificação** no nosso trabalho. Depois, podemos mesclar isso.

### **Criando ramificações no projeto**

Agora que entendemos como funciona o processo no Visualizing Git, vamos fazer o mesmo no projeto real. Com o *VS Code* aberto, vamos acessar o terminal.

Se digitarmos o comando `git branch`, ele vai retornar que só temos a branch `main`:

```
git branch
```

Poderíamos usar o comando `git branch` seguido de uma nova branch que quisermos, referente a qualquer nova funcionalidade. Porém, se quisermos criar uma branch e já mover para ela, podemos usar dois comandos. O primeiro é o `git checkout -b` seguido do nome da nova branch `nova-funcionalidade`.

```
git checkout -b nova-funcionalidade
```

---

## Git switch

Além desse comando mais antigo, podemos utilizar o `git switch`, também seguido do nome da branch desejada. "*Switch*" significa **trocar**, ou seja, esse comando basicamente alterna entre branches.

Porém, se digitarmos simplesmente `git switch nova-funcionalidade`, será informado que essa branch não existe. Então, vamos executar `git switch -c nova-funcionalidade` (`-c` referente a "*create*").

```
git switch -c nova-funcionalidade
```

Agora temos uma nova ramificação do nosso trabalho. Podemos fechar o terminal e adicionar alguma modificação no código do arquivo `index.html`. Por exemplo: vamos adicionar uma quebra de linha na imagem (`<img>`) da linha 32, logo antes dos atributos `alt` e `class`.

```html
<img src="./img/ia.png"
     alt="Uma pessoa olhando para a esquerda"
     class="container__imagem-pessoa" />
```

Essa é a nova funcionalidade que desenvolvemos, com alterações no código. Agora vamos abrir o terminal novamente e executar o comando `git status`.

```
git status
COPIAR CÓDIGO
```

Com isso, ele mostra que estamos na branch `nova-funcionalidade`. Vamos adicionar o arquivo `index.html` com o comando `git add`, e depois adicionar um `commit` com a mensagem "Quebrando linha na imagem".

```
git add index.html
```

```
git commit -m "Quebrando linha na imagem"
```

Se fizermos um `git log` agora, temos um retorno um pouco diferente.

```
git log
```

Temos o commit anterior, do *merge* na branch `main`; temos o `origin/main`; agora o último commit é onde está o `HEAD` atual; e temos a branch `nova-funcionalidade`. Repare que a branch `nova-funcionalidade` ainda não foi para o `origin`, pois não enviamos.

Porém, antes de enviar, vamos fazer um `switch` e voltar para branch `main`:

```
git switch main
```

A funcionalidade que estamos desenvolvendo está nessa branch, isto é, o commit existe nela, não descartamos ele. Porém, voltamos a trabalhar na linha de trabalho principal `main`.

Portanto, se fechamos o terminal e acessamos a tag de imagem que alteramos no código, ela estará sem quebra de linha. Se voltarmos para o terminal e executarmos `git log`, o `head` terá voltado para `main`. Então, o `HEAD` é onde estamos no momento, é o commit atual onde o nosso projeto está.

Dito isso, vamos fazer um `git switch` para `nova-funcionalidade`:

```
git switch nova-funcionalidade
```

Mais uma vez, o código aparecerá atualizado com a quebra de linha que adicionamos. Assim, podemos fazer o `git push` para o repositório remoto, ou seja, `origin` da branch `nova-funcionalidade`.

```
git push origin nova-funcionalidade

```

Após teclar "Enter", a nova ramificação será criada e teremos uma nova linha de trabalho.

Note que fizemos o `push` de `nova-funcionalidade`, e no *GitHub*, ele exibe uma mensagem que indica que podemos criar uma ***pull request*** a partir da nossa nova branch.

O GitHub já identificou que existe uma nova branch e que, em algum momento, vamos querer **unir** a branch `nova-funcionalidade` com a `main`, que é a branch principal.

> Vamos deixar um Para saber mais sobre pull requests quando colaboramos, por exemplo, em um projeto open source (de código aberto), ou até se colaboramos com uma equipe que utiliza GitHub.
> 

Basicamente, queremos unir o trabalho da branch `nova-funcionalidade` à branch `main`.

---

## **Unindo as ramificações**

Não precisamos utilizar o GitHub para esse objetivo, então vamos acessar o *[Visualizing Git](https://git-school.github.io/visualizing-git/)*.

 Em uma nova linha de trabalho, vamos adicionar dois *commits* com o comando `git commit`, criar a branch `nova-funcionalidade` com o comando `git checkout -b`, e adicionar mais dois commits a essa nova branch.

```
git commit
```

```
git checkout -b nova-funcionalidade
```

Em seguida, vamos fazer um `git switch` para a branch `master`:

```
git switch master
```

---

## Git merge

Queremos pegar tudo o que foi feito em `nova-funcionalidade` e trazer para o ramo principal `master`. Existe um comando que faz isso de forma bastante simples: o `git merge` ("mesclar" em inglês).

Você se lembra que quando fizemos o `pull` e o `push` com dois usuários diferentes, chegamos nesse cenário de ***merge***, isto é, de **mescla de trabalhos**? Podemos fazer isso ativamente.

Podemos dizer que estamos na branch `main`, a branch principal, pegar tudo o que tem na branch `nova-funcionalidade` e mesclar com o que já temos na `main`.

Se fizermos o `merge` de `nova-funcionalidade`, ele vai levar a `main` para o mesmo local.

```
git merge nova-funcionalidade

```

---

### **O que é *fast forward*?**

Existem algumas formas do `merge` ser feito. Nesse caso, ele executou o que é chamado de ***fast forward*** (mover adiante). Até o ponto da `nova-funcionalidade` ser criada, a `master` estava no terceiro commit. A partir desse ponto, criamos uma nova branch, e a branch `nova-funcionalidade` evoluiu na mesma linha, sem que a `master` tivesse novos commits.

Então, na hora de fazer o `merge`, é muito simples: não precisamos criar nenhum novo commit; o Git entende tudo e só move as coisas. Se queremos unir as coisas, a partir de agora, a branch principal estará no mesmo ponto que a `nova-funcionalidade`. Isso é o chamado fast forward.

Vamos fazer isso no terminal do *Visual Studio Code*. Começaremos fazendo o `git switch` para a branch principal `main`, e faremos um `merge` com `nova-funcionalidade`.

```
git switch main

```

```
git merge nova-funcionalidade

```

Com isso, ele fará exatamente o que dissemos: o fast forward. Isso quer dizer que ele não cria um novo commit, nem faz nada de diferente; ele simplesmente diz que, a partir de agora, a branch `main` está no mesmo lugar que a branch `nova-funcionalidade`.

Se executarmos o comando `git log --graph`, notaremos que não precisamos de uma nova ramificação.

```
git log --graph

```

### **Realizando alterações**

Vamos voltar para a branch `nova-funcionalidade` e alterar algo no código.

```
git switch nova-funcionalidade
```

Podemos acessar o arquivo `README.md`, por exemplo, e fazer alguma alteração simples. Nesse caso, vamos adicionar uma quebra de linha entre cada uma das imagens a partir da linha 8.

> README.md:
> 

```markdown
## 🚀 Tecnologias<div><img src="https://img.shields.io/badge/HTML-239120?style=for-the-badge&logo=html5&logoColor=white"><img src="https://img.shields.io/badge/CSS-239120?&style=for-the-badge&logo=css3&logoColor=white"><img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"></div>COPIAR CÓDIGO
```

Novamente, o comando `git status` vai nos mostrar que estamos na branch `nova-funcionalidade`:

```
git status
```

Vamos adicionar o arquivo `README.md` com o comando `git add` e, na sequência, adicionar um novo `commit` com a mensagem "Quebra de linha entre imagens". Podemos até fazer o `git push` de `nova-funcionalidade` para ir ao repositório remoto.

```
git add README.md
```

```
git commit -m "Quebra de linha entre imagens"
```

```
git push origin nova-funcionalidade
```

Feito isso, vamos voltar para a branch `main`.

```
git switch main
```

Imagine que outras funcionalidades estão acontecendo e outras pessoas estão desenvolvendo. Dito isso, vamos ao arquivo `style.css`, por exemplo, e mudaremos a propriedade `font-size` da tag `h1` de `50px` para `51px`, dentro do `@media screen` na linha 116.

> style.css:
> 

```css
@media screenand (max-width: 1250px) {

h1 {
        font-size: 51px;
    }
COPIAR CÓDIGO
```

É isso que vai acontecer: vamos adicionar o arquivo de estilo com o comando `git add`, e a mensagem do `commit` será "Aumentando a fonte".

```
git add style.css
```

```
git commit -m "Aumentando a fonte"
```

Agora, se executarmos o comando `git log`, temos o commit "Aumentando a fonte". Se alternarmos para a branch `nova-funcionalidade` com `git switch`, e executarmos novamente `git log` para verificar o que temos em `nova-funcionalidade`, o commit "Aumentando a fonte" não fará parte dessa linha de trabalho.

### **Fazendo um *merge commit***

Estamos no cenário onde as duas branches evoluíram de forma **independente**. Este é o cenário mais comum: trabalhamos na branch de alguma funcionalidade, e outras funcionalidades foram adicionadas à `main`, outras coisas foram feitas e já estão na linha de trabalho principal.

Sendo assim, quando fizermos um `git switch` para `main` e tentarmos fazer um `git merge` de `nova-funcionalidade`, o Git vai entender que esses dois trabalhos estão independentes e não evoluíram de forma igual. Dessa forma, ele irá unir criando um novo commit automaticamente. Ele criará um novo commit de merge, ou ***merge commit***, como normalmente é chamado nas documentações.

```
git switch main
```

```
git merge nova-funcionalidade
```

Com esses comandos, será aberto um editor que permite a alteração da mensagem de commit de merge. No nosso caso, vamos deixar o commit como está.

Como o editor é o VI, basta executar `:x` para salvar e sair. Ao final, teremos um novo commit criado. Se executarmos o comando `git log --graph`, podemos observar o que acontece na `main`.

Primeiramente, temos o commit "Quebrando linha na imagem". Depois ele cria uma nova linha de trabalho, onde temos o commit "Aumentando a fonte". Na sequência, temos "Quebra de linha entre imagens", e por último o merge commit, isto é, o commit de **mescla**.

Reparem que bifurcamos o nosso trabalho e depois unimos. Lembrando que tudo isso é feito automaticamente pelo Git, mas é importante entender que existem essas duas estratégias: de **fast forward** e de criação do **merge commit**.

Dessa forma, conseguimos unir trabalho de duas branches diferentes para ter tudo na linha principal. Agora a nossa linha principal possui toda a `nova-funcionalidade`. O ramo `nova-funcionalidade` foi completo, unimos à linha principal, então agora podemos fazer ***deploy*** da nossa aplicação.

### **Ajustes finais**

Para finalizar, vamos executar o comando `git push origin main` para atualizar a `main` com todo o trabalho novo. Em seguida, removeremos a branch `nova-funcionalidade` com `git branch -d`, para manter o projeto limpo e sem excesso de branches.

```
git push origin main
COPIAR CÓDIGO
```

```
git branch -d nova-funcionalidade
COPIAR CÓDIGO
```

Ainda podemos remover a branch `nova-funcionalidade` do repositório remoto no GitHub. Para isso, executamos o seguinte comando:

```
git push origin :nova-funcionalidade
COPIAR CÓDIGO
```

> Os dois pontos (:) indicam que estamos removendo no repositório remoto.
> 

O GitHub possui uma funcionalidade chamada *Pull requests*, que é uma sugestão de alteração em determinado repositório. Outras ferramentas, como o GitLab, podem chamar essa mesma ferramenta de *Merge requests*.

Essa sugestão de alteração é, de forma resumida, a abordagem que adotamos ao colaborar com equipes para adicionar novas funcionalidades ou corrigir alterações. Ao invés de manualmente mesclarmos o código de nossa *branch* com a *main*, nós criamos um *pull request* (ou *merge request*), pois dessa forma a alteração fica mais visível para toda a equipe e permite que outras pessoas possam revisar esse trabalho.

Há muitas outras funcionalidades em *pull requests*, mas essa explicação já é um bom começo. Se você quiser ver um *pull request* na prática para um projeto de código aberto, no vídeo **Contribuindo para projetos open source - Criando um pull request real no GitHub** eu mostro exatamente isso.

# **Atualizando a branch**

No *Visualizing Git*, encontramos o cenário que reproduzimos na última aula.

!https://cdn1.gnarususercontent.com.br/1/795715/7aacfa0d-a8b8-4cce-a7da-9b49c8556fef.png

Temos a *branch* principal, ramificamos uma nova funcionalidade, criamos dois *commits* e depois fizemos um *merge*, ou seja, um novo *commit* foi criado com a junção desses dois trabalhos. Basicamente, é isso que fazemos quando temos um *merge*, quando temos dois trabalhos bifurcados.

Agora, criaremos um novo cenário. Então, rodamos o comando `clear` para limpar o *Visualizing Git*.

```css
clear
COPIAR CÓDIGO
```

Em sequencia, adicionamos uma nova *branch* chamada `main`, então passamos `git checkout -b main`.

```css
git checkout -bmainCOPIAR CÓDIGO
```

Em sequência, removemos a *branch* chamada `master` para já nos adaptarmos com os nomes corretos. Então passamos o comando `git branch -d master`.

```
git branch -d master
COPIAR CÓDIGO
```

> Recapitulando, o git checkout é um comando antigo que faz muita coisa. Contudo, o Visualizing Git não foi atualizado para ter o comando git switch. Mas, normalmente, utilizamos o comando git switch, que é mais simples.
> 

Continuando, adicionaremos alguns *commits* na *branch* `main`, faremos isso sem mensagem, só *commits* vazios. Passamos `git commit` duas vezes.

```sql
gitcommitCOPIAR CÓDIGO
```

Agora criaremos um novo *branch* passando `git branch nova-funcionalidade`.

```
git branch nova-funcionalidade
COPIAR CÓDIGO
```

Criamos um novo *branch*, mas ainda estamos na `main`, não na `nova-funcionalidade`. Após, adicionamos mais dois *commits* na *branch* `main` passando `git commit`.

Agora, voltamos para o `git checkout nova-funcionalidade` para trabalharmos nela.

```
git checkout nova-funcionalidade
COPIAR CÓDIGO
```

Em seguida adicionamos dois commits, passando duas vezes o código abaixo.

```sql
gitcommitCOPIAR CÓDIGO
```

O cenário que montamos no *Visualizing Git*, criamos uma nova *branch* chamada `nova-funcionalidade` e estamos trabalhando nela. Enquanto trabalho nessa *branch*, outras pessoas podem ter criado outros *branches* e já se uniram à linha principal, à `main`. Normalmente, essa `main` é o projeto final que pode ser enviado à produção. É o projeto com todas as funcionalidades que estejam completas.

Estamos criando uma nova funcionalidade, porém queremos testá-la na versão mais recente do projeto. Repare que, a partir do momento em que criamos a `nova-funcionalidade`, dois outros commits também foram criados, ou seja, duas funcionalidades foram adicionadas no projeto principal.

Queremos garantir que o que estamos desenvolvendo funcione, mesmo com as funcionalidades que as outras pessoas criaram. Queremos garantir que tudo se integre da forma correta.

Sendo assim, queremos fazer com que a branch `nova-funcionalidade` não seja criada a partir da versão antiga da branch `main`e sim da versão mais nova.

Portanto, queremos reescrever a história, fazendo com que o primeiro *commit* da nova funcionalidade venha logo após do momento atual da `main` atualizada. Queremos fazer com que a *branch* `nova-funcionalidade`, seja reescrito para ter todas as funcionalidades da `main` antes dela.

## Git rebase:

Isso pode ser feito com um comando mágico chamado `git rebase`, que faz muita coisa, como **reescrever a história dos *commits***. Então, se estivermos em `nova-funcionalidade` e executarmos o comando `git rebase main`, ele pegará todos os *commits* da `main` que não estão na *branch* `nova-funcionalidade`, e tentar adicionar um a um antes da *branch* `nova-funcionalidade`.

```css
git rebasemain
```

Ele pegará o primeiro *commit* e tentar adicionar antes do *commit* `nova-funcionalidade`. Pegará o próximo *commit*, que é o último da `main`, e tentar adicionar antes do *commit* `nova-funcionalidade`. Após isso, pega todos os *commits* da `nova-funcionalidade` e aplica depois do último da `main`.

Pode parecer bastante complexo, mas se visualizarmos o que está acontecendo, talvez fique um pouco mais fácil. Ele primeiro traz o *head* para a `main` e depois aplica tudo da `nova-funcionalidade`, cada um dos *commits*, depois. Vai aplicando *commit* a *commit* depois da última coisa que estiver na `main`.

Recapitulando novamente. Temos duas *branches* independentes, uma `main` e uma `nova-funcionalidade`. Se queremos garantir que essa `nova-funcionalidade` agora tenha tudo o que tem na `main` também, podemos fazer o `rebase`.

O `rebase` fará o quê? Se estamos na `nova-funcionalidade` e tentamos fazer o `rebase` com a `main`, ele vai alterar o *branch* para ir para a `main`. Depois da `main`, ele vai aplicando cada um dos *commits* da `nova-funcionalidade`. Isso é feito *commit* por *commit*, porque se tiver algum conflito em algum dos *commits*, vamos resolvendo um a um. Dessa forma, conseguimos reescrever a história.

Reparem que agora o `nova-funcionalidade` possui dois *commits* com *hashes* diferentes, porque vieram de outro lugar a partir de uma nova história. Vamos fazer isso, na prática.

Para isso, abrimos o projeto no VS Code, limpamos o terminal e passamos o comando `git status`.

```lua
git status
COPIAR CÓDIGO
```

Agora estamos na `main`. Então, passamos o comando `git switch -c nova-funcionalidade`. Vou criar mais uma `nova-funcionalidade`.

```r
git switch -c nova-funcionalidade
COPIAR CÓDIGO
```

Agora, corrigiremos a indentação do link na linha 10 para que o atributo `rel` esteja na mesma coluna do meu atributo `href`. Fizemos uma alteração simples.

No terminal, adicionamos esse *commit*. Então, escrevemos `git add index.html`.

```csharp
gitadd index.html
COPIAR CÓDIGO
```

Seguido de `git commit -m "Corrigindo indentação"`.

```sql
gitcommit -m "Corrigindo indentação"
COPIAR CÓDIGO
```

Vamos quebrar também o `<script>` para que a abertura e o fechamento dessa tag fiquem em linhas diferentes.

```xml
//Código omitido

<script src="https://code.responsivevoice.org/responsivevoice.js">
</script>

//Código omitido
COPIAR CÓDIGO
```

Feito isso, no terminal passamos `git add index.html`, seguido de `git commit -m "Quebrando linha do script"`.

```sql
gitcommit -m "Quebrando linha do script"
COPIAR CÓDIGO
```

Temos a `nova-funcionalidade` sendo desenvolvida. Agora, faremos o `git switch` para `main`. Imagine que alguma outra nova funcionalidade será adicionada no ramo principal.

Quebraremos a linha referente ao botão de chute para que o texto `Chutar` fique separado das tags de abrir e fechar `<button>`. Fazemos o mesmo em `Novo Jogo`.

```jsx
//Código omitido

    <divclass="chute container__botoes">
            <button onclick="verificarChute()" class="container__botao">
                Chutar
            </button><button onclick="reiniciarJogo()" id="reiniciar" class="container__botao" disabled>
                Novo jogo
            </button>
    </div>
</div>

//Código omitido
COPIAR CÓDIGO
```

Feito isso, salvamos. No terminal, adicionamos `git add index.html`, seguido do `git commit -m "Indentando botões"`.

```sql
gitcommit -m "Indentando botões"
COPIAR CÓDIGO
```

Na *branch* `main`, temos uma nova funcionalidade que indentou os botões. Se fazemos `git switch nova-funcionalidade`, temos a indentação das tags no início do arquivo. Só que queremos garantir que o arquivo `index.html` esteja correto mesmo se pegarmos tudo da última versão da `main`. Então, primeiro passamos o comando `git log --`.

```lua
git log --
COPIAR CÓDIGO
```

Assim é exibido que temos `Corrigindo indentação`, mostrando a linha do *script* depois do `origin/main`, mas não do `main/local`, pois tem um *commit* novo. Limpamos a tela e passamos o `git rebase main`.

```css
git rebasemainCOPIAR CÓDIGO
```

Isso faz um `git switch` para `main`, pega cada um dos *commits* que temos nessa `nova-funcionalidade` e tenta aplicar a partir desse novo momento. Depois, move novo *branch* para a nova linha. Então, fazemos o `git rebase main`.

```css
git rebasemainCOPIAR CÓDIGO
```

Repare que primeiro, estamos fazendo o *rewind*, ou seja, estamos voltando para o início dessa *branch*. Depois, estamos aplicando o *commit* de corrigir a indentação e aplicamos o *commit* de quebrando a linha do *script*. Deu tudo certo!

Se passarmos `git log` agora, reparem que o *branch* `nova-funcionalidade` começa a partir do *branch* `main`, do novo `main` que criamos localmente. Então, reescrevi a história. Agora, podemos fazer o `git push origin main`.

```css
git push originmainCOPIAR CÓDIGO
```

Seguido de `git push origin nova-funcionalidade`.

```perl
gitpush origin nova-funcionalidade
COPIAR CÓDIGO
```

Estamos mandando tudo para o repositório remoto. Claro, podemos voltar para o `git switch main` e fazer um `git merge nova-funcionalidade`.

## Git Merge

O comando **`git merge`** é utilizado para mesclar alterações de diferentes ramos no Git. Quando você tem dois ramos, como um ramo de desenvolvimento e um ramo de feature, e deseja incorporar as alterações de um ramo para o outro, você usa o **`git merge`**.

A sintaxe básica do comando é:

```arduino
arduinoCopy code
git merge <nome-do-ramo>

```

Onde **`<nome-do-ramo>`** é o nome do ramo que você deseja mesclar com o ramo atual.

Por exemplo, se você estiver no ramo **`main`** e quiser mesclar as alterações do ramo **`feature`**, você executaria:

```sql
sqlCopy code
git merge feature

```

Isso combinará as alterações do ramo **`feature`** com o ramo **`main`**. Se houver conflitos durante a mesclagem (ou seja, o Git não conseguirá combinar automaticamente as alterações), você precisará resolvê-los manualmente.

Além disso, você pode encontrar opções adicionais para o comando **`git merge`**, como **`--no-ff`**, que força uma "mesclagem de commit" mesmo que o Git possa fazer uma "mesclagem rápida" (fast-forward), ou **`--squash`**, que mescla todas as alterações em um único commit. Estas são utilizadas em situações específicas, dependendo do fluxo de trabalho e das preferências da equipe.

Em resumo, **`git merge`** é usado para combinar o histórico de commits de dois ramos diferentes em um único ramo.

Com isso, ele vai conseguir fazer o *fast-forward* porque já fiz o `rebase`, então não precisa daquele *commit* de *merge*. Porque, novamente, ele já reescreveu a história garantindo que os dois *branches* não sejam mais separados e sim que podem estar juntos.

Reparem que quando fazemos o `merge`, conseguimos fazer o `fast-forward`. Então, agora, novamente fazemos o `git push origin main` que agora tem a `nova-funcionalidade`.

Um detalhe importante antes de finalizar e que `fast-forward`, `commit` de `merge`, parecem ser detalhes bem pequenos e, na verdade, são. Quando estamos trabalhando, podemos simplesmente executar o `git merge` sem saber se ele vai fazer o `fast-forward` ou se vai fazer um *commit* de `merge`.

Porém, em algumas empresas, podem ter políticas onde todos os `merges` precisem ser feitos com o `fast-forward`. Então, antes de qualquer `merge`, é preciso fazer um `rebase`.

Também pode ser o contrário, precisamos garantir que nunca utilizaremos o `fast-forward` para sempre ter no grafo do *log* as ramificações. Então, podemos utilizar estratégias para isso também.

Mas, para o nosso cenário, já é o suficiente conhecer os comandos `merge` para mesclar trabalhos e o comando `rebase` para reescrever a história e garantir que uma nova *branch* possa ser atualizada a partir de uma *branch* anterior.

O trabalho do `rebase` é equivalente ao que vimos na prática como *fast forward* do merge. Ao realizar o `rebase`, todos os commits da outra *branch* são adicionados **antes** do primeiro commit da nossa *branch* atual, reescrevendo a história. Isso faz com que novas alterações possam ser integradas à nossa branch e permite que quando formos realizar o `merge`, não seja necessário um *merge commit*, garantindo o *fast forward*.

## **Nessa aula, nós:**

- Entendemos o problema que *branches* resolvem ao colaborar com uma equipe em um projeto, organizando a colaboração, evitando conflitos e garantindo que uma funcionalidade seja enviada apenas quando estiver pronta;
- Conhecemos os comandos `git branch` e `git switch` para manipular as *branches* existentes;
- Vimos como unir o trabalho de duas *branches* com o comando `git merge`;
- Aprendemos sobre as abordagens de *merge commit* e *fast forward* do `git merge`;
- Conseguimos reescrever a história de uma *branch* utilizando o comando `git rebase`.

Se você conhece o git com certeza já usou o comando **git checkout**. As novas versões do git mexeram nesse comando para deixar ele mais coerente. Na verdade o *git checkout* foi separado em dois comandos:

- `git restore`
- `git switch`

---

### **Recuperando as alterações**

Podemos executar o comando `git stash pop`. Esse *pop*, ele aplica o que tiver na nossa gaveta, no nosso estoque.

Após executarmos o `git stash pop`, a função não está mais na linha 12. Então, podemos continuar a implementação e trazê-la para cima. Agora temos o nosso estado finalizado.

> Portanto, o git stash guarda uma alteração para que ela possa ser retomada depois.
> 

Ele guarda um estado para que possamos retomá-lo depois. E normalmente é utilizado quando estamos no meio de uma alteração, queremos guardar algo rapidamente para corrigir um bug e trabalhar em outra coisa rapidamente e depois voltar a trabalhar nisso. Portanto, não podemos criar um *commit*.

Um detalhe: vamos criar esse *stash* novamente. Vamos limpar o nosso terminal e rodar o `git stash`. Se executarmos o comando `git stash list`, ele lista tudo o que está nesse nosso estoque. E repare que temos duas coisas no nosso *stash*, já tínhamos adicionado algo antes.

```csharp
$ git stash list
stash@{0}: WIPon movendo-detalhes: c53eb16 Quebrando linhado script
stash@{1}: WIPon main: c53eb16 Quebrando linhado script
$
COPIAR CÓDIGO
```

Digamos que não queremos mais nada na *stash*. Ou então, queremos fazer o `git stash pop` primeiro para recuperar essa nossa alteração. Feito o `git stash pop`, a nossa alteração voltou a aparecer e estamos com o nosso código no estado correto.

Mas repare que os nomes que esse nosso `git stash list` nos mostra não são muito descritivos. Ele coloca um *work in progress* (*WIP*) na *branch* que estávamos e o último *commit* antes de adicionarmos esse *stash*. Portanto, isso não é muito útil.

### **Limpando as alterações guardadas**

Vamos mostrar duas coisas. A primeira é que temos aqui no nosso `git stash list` algo anterior que fizemos alguns testes que não fazem parte dessa aula. Portanto, como podemos limpar a nossa *stash*, apagar tudo? Podemos fazer um `git stash clear`, limpamos a nossa *stash*. Portanto, se fizermos o `git stash list`, não tem mais nada lá.

### **Acrescentando uma descrição à `stash`**

Agora, se quisermos adicionar algo a nossa *stash*, mas com um nome mais descritivo, podemos fazer, ao invés de só `git stash`, vamos escrever `git stash push -m`. E aí, podemos adicionar uma mensagem qualquer, será `"Movendo chamada de função"`.

```perl
git stashpush -m "Movendo chamada de função"
COPIAR CÓDIGO
```

Quando voltamos lá para o nosso código, a alteração foi desfeita. E se fizermos um `git stash list`, temos um nome bem mais descritivo: `Movendo chamada de função`. Agora, sabemos o que isso significa. E podemos adicionar várias coisas na *stash*, como mostramos.

Por exemplo, temos algo na nossa *stash* e vamos adicionar algo mais. Como, por exemplo, vamos remover todas essas quebras de linhas no final. Fizemos várias quebra de linha, estamos no meio da implementação, tivemos que parar de novo. Usamos o comando `git stash` novamente.

Fizemos um `git stash`, adicionamos essa modificação lá na nossa lista de modificações que queremos rever depois. Se escrevermos `git stash list`, ele listará o `movendo chamada de função` e a última `stash` que não tem um nome específico. Portanto, ela aparece como `WIP on movento-detalhes: c53eb16 Quebrando linha do script`.

### **Entendendo a pilha de modificações**

Se fizermos um `git stash pop`, ele sempre vai aplicar a última alteração que adicionamos. Portanto, ele sempre pega esse de índice zero. Ele sempre vai empilhando modificações.

O que isso quer dizer? Imagina que essa nossa `stash` é uma gaveta e nessa gaveta estamos guardando pratos. Portanto, abrimos a gaveta, colocamos um prato. Na gaveta, adicionamos outro prato em cima. Se vamos pegar um prato, pegamos o prato que está em cima, certo? Portanto, é o último que adicionamos. Isso é o **conceito de pilha**.

Temos aqui na *stash* uma **pilha de modificações**. Portanto, quando fazemos *pop*, sempre aplicamos a última que adicionamos. Fizemos um `git stash pop`, temos a remoção das quebras de linha.

Portanto, se fizermos nosso `git stash list` de novo, só temos um e agora o nosso índice zero é aquela `movendo chamada da função`. Só que, imagina o seguinte cenário: Removemos todas as quebras de linha e vamos fazer o `git stash` de novo.

### **Retomando alterações anteriores à versão mais recente**

No nosso `git stash list`, temos lá a `movendo chamada da função`, que agora é o índice 1. E o novo índice zero é essa remoção de quebras de linha lá do final. Só que o que queremos voltar a trabalhar no que está guardado nesse índice 1.

```kotlin
$ git stash list
stash@{0}: WIP on movendo-detalhes: c53eb16 Quebrando linhado script
stash@{1}: On movendo-detalhes: Movendo chamada defunção
$
COPIAR CÓDIGO
```

Portanto, se fizermos o `git stash pop`, não vai funcionar. Vamos pegar a última alteração que não é o que queremos. Portanto, nesses cenários, quando queremos aplicar algo que está na `stash` anterior à versão mais recente, podemos fazer o `git stash apply` e o índice, no nosso caso, o índice 1, que é o `movendo chamada da função`.

Antes de executar, temos todas as quebras de linha no final do arquivo e a chamada da função está na linha 17. Vamos executar agora no nosso terminal, `git stash apply 1`. O que vai acontecer? Temos a nossa função sendo movida, mas todas as quebras de linha continuam lá no final.

Se quisermos, podemos aplicar mais de um item de `stash`. Portanto, podemos fazer aqui o nosso `git stash pop` sem problema. Só que aí vamos ter um conflito.

> Podemos aplicar várias stashes se elas não estiverem no mesmo arquivo, se elas não forem conflitar com o que temos.
> 

Temos modificações no arquivo que seriam sobrescritas. Portanto, não vamos aplicar essa `stash` mais. Portanto, se fizermos um `stash list`, ele adicionou um novo detalhe lá na nossa `stash`.

Para recapitular, se temos alguma alteração que precisamos adicionar ou salvar para depois, chamamos o comando `git stash`. O comando `git stash` vai adicionando mensagens no formato de pilha.

Recapitulando:

- Se queremos pegar algo e aplicar uma alteração à última `stash` que adicionamos, usamos `git stash pop`;
- Se queremos aplicar alguma específica, usamos `git stash apply`;
- Se queremos adicionar algo na nossa `stash` com mensagem, usamos `git stash push`;
- Se queremos limpar a nossa `stash`, usamos `git stash clear`.

Vamos desfazer a alteração de mover. Não queremos mover essa mensagem, queremos fazê-la voltar para onde ela estava originalmente. Portanto, agora temos o nosso código no estado original, certo?

No entanto, se fizermos um `git status`, temos uma alteração ainda. Se fizermos um `git diff`, repare que essa alteração é invisível para nós.

Portanto, provavelmente, o nosso Visual Studio Code apagou alguns espaços que estavam em uma linha. Só que não queremos comitar isso, queremos desfazer essa alteração. Como podemos desfazer alterações que estão prontas para serem adicionadas a um *commit*? Através do `git`. É isso que vamos fazer no próximo vídeo.

Os comandos `pop`, `drop` e `apply` do `git stash` possuem semelhanças e diferenças bem importantes, então vamos fazer um pequeno resumo de suas funcionalidades aqui:

### **Apply**

O comando `git stash apply` espera um índice de um item na *stash* e o aplica ao repositório, porém, esse comando **não remove** o item da *stash*, ou seja, se após executar o comando `git stash apply 1` você executar `git stash list`, o item referente ao índice 1 continuará na *stash*.

### **Pop**

O `git stash pop` faz exatamente a mesma coisa que o `git stash apply`, porém, além de aplicar o item da *stash*, ele também o remove de lá. Esse comando, sem nenhum parâmetro extra, vai aplicar o último item adicionado à *stash*, mas nós também podemos informar um índice para ele, como `git stash pop 1`.

### **Drop**

O `git stash drop` funciona exatamente como o `pop`, mas com uma simples diferença: ele apenas remove o item da *stash*, sem aplicá-lo em nosso repositório. Dessa forma, `git stash drop` remove o último item adicionado à *stash*, enquanto o `git stash drop 1` remove da *stash* o item com índice 1.

---

o comando `git restore` pode restaurar estados de um arquivo ou de um projeto inteiro. Dissemos que queríamos "viajar no tempo", mas antes precisamos mostrar um detalhe interessante.